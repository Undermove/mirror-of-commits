<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Topdown Shooter: Zombies</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0f0f12; color: #e6e6e6; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    canvas { display: block; width: 100vw; height: 100vh; cursor: crosshair; }
    #ui { position: fixed; left: 16px; top: 12px; z-index: 10; user-select: none; }
    #ui .stat { font-weight: 700; font-size: 14px; line-height: 1.2; margin-bottom: 6px; }
    #ui .hint { opacity: .7; font-size: 12px; }

    .overlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,.5); z-index: 20; }
    .overlay.show { display: flex; }
    .panel { background: rgba(20,20,26,.9); padding: 24px 28px; border: 1px solid rgba(255,255,255,.1); border-radius: 12px; text-align: center; box-shadow: 0 8px 30px rgba(0,0,0,.6); }
    .panel h1 { margin: 0 0 8px; font-size: 24px; }
    .panel p { margin: 6px 0 0; opacity: .85; }
    .upgrade-grid { display: grid; grid-template-columns: 1fr; gap: 10px; margin-top: 12px; }
    .upgrade-btn { cursor: pointer; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,.15); background: rgba(255,255,255,0.04); color: #fff; font-weight: 600; text-align: left; position: relative; }
    .upgrade-btn:hover { background: rgba(255,255,255,0.08); }
    .upgrade-btn:focus-visible { outline: 2px dashed #7cd1ff; outline-offset: 2px; }
    .upgrade-note { opacity: .85; font-size: 13px; margin-top: 6px; }
    .upgrade-btn[disabled] { opacity: .5; cursor: not-allowed; }
    .label-row { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .lvl { opacity:.9; font-weight:700; }
    .progress { height: 6px; border-radius: 6px; background: rgba(255,255,255,0.08); overflow:hidden; margin-top:8px; }
    .progress-fill { height:100%; width:0%; background: linear-gradient(90deg, #5bd7ff, #7aff8f); border-radius: inherit; box-shadow: 0 0 8px rgba(123,255,168,0.5); }
  </style>
</head>
<body>
  <div id="ui">
    <div class="stat" id="score">Score: 0</div>
    <div class="stat" id="health">HP: 100</div>
    <div class="stat" id="ammo">Ammo: </div>
    <div class="stat" id="countdown"></div>
    <div class="hint">WASD: –¥–≤–∏–∂–µ–Ω–∏–µ ‚Ä¢ –ú—ã—à—å: –ø—Ä–∏—Ü–µ–ª ‚Ä¢ –õ–ö–ú: —Å—Ç—Ä–µ–ª—è—Ç—å ‚Ä¢ R: —Ä–µ—Å—Ç–∞—Ä—Ç</div>
  </div>
  <canvas id="game"></canvas>

  <div class="overlay" id="gameover">
    <div class="panel">
      <h1>–í—ã –ø–æ–º–µ—Ä–ª–∏. –ó–æ–º–±–∏ —Å–æ–∂—Ä–∞–ª–∏ –≤–∞—à–∏ –º–æ–∑–≥–∏</h1>
      <p id="final">–°—á—ë—Ç: 0</p>
      <p>–ù–∞–∂–º–∏—Ç–µ R –¥–ª—è —Ä–µ—Å—Ç–∞—Ä—Ç–∞</p>
    </div>
  </div>
  
  <div class="overlay" id="upgrade">
    <div class="panel">
      <h1>–ü—Ä–æ–∫–∞—á–∫–∞ –¥—Ä–æ–±–æ–≤–∏–∫–∞</h1>
      <p>–í–æ–ª–Ω–∞ –∑–∞—á–∏—â–µ–Ω–∞. –í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω–æ —É–ª—É—á—à–µ–Ω–∏–µ (–∫–∞–∂–¥–æ–µ –¥–æ 5 —Ä–∞–∑):</p>
      <div class="upgrade-grid">
        <button class="upgrade-btn" id="upg-damage">
          <div class="label-row"><span>üí• –£—Ä–æ–Ω +50% (—Ç–æ–ª—â–µ —Å—Ç–≤–æ–ª)</span><span class="lvl" id="lvl-damage">0/5</span></div>
          <div class="progress"><div class="progress-fill" id="bar-damage"></div></div>
        </button>
        <button class="upgrade-btn" id="upg-stopping">
          <div class="label-row"><span>üßä –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—â–∞—è —Å–∏–ª–∞ (—Å–∏–ª—å–Ω–µ–µ –∏ –¥–æ–ª—å—à–µ, —Å—Ç–≤–æ–ª –¥–ª–∏–Ω–Ω–µ–µ)</span><span class="lvl" id="lvl-stopping">0/5</span></div>
          <div class="progress"><div class="progress-fill" id="bar-stopping"></div></div>
        </button>
        <button class="upgrade-btn" id="upg-speed">
          <div class="label-row"><span>üöÄ –°–∫–æ—Ä–æ—Å—Ç—å –ø—É–ª–∏ +15% (–≤–∏–¥ ¬´–∫—Ä—É—á–µ¬ª)</span><span class="lvl" id="lvl-speed">0/5</span></div>
          <div class="progress"><div class="progress-fill" id="bar-speed"></div></div>
        </button>
        <button class="upgrade-btn" id="upg-pellets">
          <div class="label-row"><span>üî± –ö–æ–ª-–≤–æ –ø—É–ª—å +7 (–¥–æ–±–∞–≤–ª—è–µ—Ç —Å—Ç–≤–æ–ª)</span><span class="lvl" id="lvl-pellets">0/5</span></div>
          <div class="progress"><div class="progress-fill" id="bar-pellets"></div></div>
        </button>
        <button class="upgrade-btn" id="upg-endless" style="display:none; text-align:center">‚öîÔ∏è –î–µ—Ä–∏—Å—å –¥–æ –∫–æ–Ω—Ü–∞!</button>
      </div>
      <p class="upgrade-note">–í–Ω–µ—à–Ω–∏–π –≤–∏–¥ –¥—Ä–æ–±–æ–≤–∏–∫–∞ –º–µ–Ω—è–µ—Ç—Å—è –∏ —Å–æ—á–µ—Ç–∞–µ—Ç—Å—è —Å –¥—Ä—É–≥–∏–º–∏ –∞–ø–≥—Ä–µ–π–¥–∞–º–∏.</p>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const uiScore = document.getElementById('score');
    const uiHP = document.getElementById('health');
    const uiAmmo = document.getElementById('ammo');
    const uiCountdown = document.getElementById('countdown');
    const overlay = document.getElementById('gameover');
    const final = document.getElementById('final');
    const upgOverlay = document.getElementById('upgrade');
    const btnDamage = document.getElementById('upg-damage');
    const btnStopping = document.getElementById('upg-stopping');
    const btnSpeed = document.getElementById('upg-speed');
    const btnPellets = document.getElementById('upg-pellets');
    const btnEndless = document.getElementById('upg-endless');
    const barDamage = document.getElementById('bar-damage');
    const barStopping = document.getElementById('bar-stopping');
    const barSpeed = document.getElementById('bar-speed');
    const barPellets = document.getElementById('bar-pellets');
    const lblDamage = document.getElementById('lvl-damage');
    const lblStopping = document.getElementById('lvl-stopping');
    const lblSpeed = document.getElementById('lvl-speed');
    const lblPellets = document.getElementById('lvl-pellets');
    if (btnDamage) btnDamage.addEventListener('click', ()=>applyUpgrade('damage'));
    if (btnStopping) btnStopping.addEventListener('click', ()=>applyUpgrade('stopping'));
    if (btnSpeed) btnSpeed.addEventListener('click', ()=>applyUpgrade('speed'));
    if (btnPellets) btnPellets.addEventListener('click', ()=>applyUpgrade('pellets'));
    if (btnEndless) btnEndless.addEventListener('click', ()=>startEndless());

    const state = {
      w: 0, h: 0, dpr: window.devicePixelRatio || 1,
      running: true,
      score: 0,
      time: 0,
      spawnTimer: 0,
      spawnInterval: 1.1,
      keys: new Set(),
      mouse: {x: 0, y: 0, down: false, justPressed: false},
      bullets: [],
      zombies: [],
      splats: [],
      explosions: [],
      barrels: [],
      quips: [],
      scorches: [],
      covers: [],
      draggingCover: null,
      phase: 'fight',
      zombiesSpawned: 0,
      weakPhase: true,
      weakSide: 0,
      shotsFired: 0,
      nextQuipAt: 35,
      player: null,
      shake: 0,
      wave: 1,
      waveCap: 190,
      waveCapped: false,
      endlessShown: false,
      endlessMode: false,
      zombieId: 0
    };

    function resize() {
      state.dpr = window.devicePixelRatio || 1;
      state.w = Math.max(320, window.innerWidth);
      state.h = Math.max(240, window.innerHeight);
      canvas.width = Math.floor(state.w * state.dpr);
      canvas.height = Math.floor(state.h * state.dpr);
      ctx.setTransform(state.dpr,0,0,state.dpr,0,0);
    }

    // Seeded random helpers for deterministic per-zombie variations
    function mulberry32(a){
      return function(){
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }
    function seeded01(seed){ const r = mulberry32(seed>>>0); return r(); }

    // Wave cap progression: 130, 160, 190, ... (+30 per wave)
    function getWaveCap(w){
      const n = Math.max(1, Math.floor(w||1));
      return 130 + (n-1)*30;
    }

    class Cover{
      constructor(x,y,w,h, hp){
        // x,y as top-left for init; store as center with rotation and velocities
        this.cx = x + w*0.5; this.cy = y + h*0.5; this.w=w; this.h=h;
        this.angle = Math.random()*Math.PI*2;
        this.vx = 0; this.vy = 0; this.av = 0;
        const area = w*h; const density = 0.002;
        this.mass = Math.max(1, density*area);
        this.invMass = 1/this.mass;
        const I = (this.mass*(w*w + h*h))/12;
        this.inertia = Math.max(1e-3, I);
        this.invInertia = 1/this.inertia;
        this.hp = hp; this.maxHp = hp;
      }
      radius(){ return Math.hypot(this.w, this.h)*0.5; }
      clampToBounds(){
        const r = this.radius();
        this.cx = clamp(this.cx, r, state.w - r);
        this.cy = clamp(this.cy, r, state.h - r);
      }
      integrate(dt){
        this.cx += this.vx*dt; this.cy += this.vy*dt; // keep angle fixed (no rotation)
        // small friction (damping) ‚Äî –º–µ–¥–ª–µ–Ω–Ω–æ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ (–ª–∏–Ω–µ–π–Ω–∞—è), –±–µ–∑ —É–≥–ª–æ–≤–æ–π –∏–Ω–µ—Ä—Ü–∏–∏
        const linD = Math.pow(0.9, dt);  // ~0.9 –∑–∞ —Å–µ–∫—É–Ω–¥—É
        this.vx *= linD; this.vy *= linD; this.av = 0;
        this.clampToBounds();
      }
      draw(){
        const t = clamp(this.hp/this.maxHp, 0, 1);
        const base = 40 + Math.floor(60*t);
        ctx.save();
        ctx.translate(this.cx, this.cy);
        ctx.rotate(this.angle);
        ctx.fillStyle = `rgb(${base},${base},${base})`;
        ctx.fillRect(-this.w*0.5, -this.h*0.5, this.w, this.h);
        // outline
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 2;
        ctx.strokeRect(-this.w*0.5+0.5, -this.h*0.5+0.5, this.w-1, this.h-1);
        ctx.restore();
        // hp bar above
        ctx.fillStyle = 'rgba(200,40,40,0.8)';
        ctx.fillRect(this.cx - this.w*0.5, this.cy - this.h*0.5 - 8, this.w*t, 4);
      }
    }

    class Scorch{
      constructor(x,y){ this.x=x; this.y=y; this.r=70; this.ttl=18; }
      update(dt){ this.ttl -= dt; }
      draw(){
        const t = Math.max(0, Math.min(1, this.ttl/18));
        const alpha = 0.25 * t;
        const grad = ctx.createRadialGradient(this.x, this.y, 10, this.x, this.y, this.r);
        grad.addColorStop(0, `rgba(0,0,0,${alpha})`);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, TAU); ctx.fill();
      }
    }

    class Barrel{
      constructor(x,y){ this.x=x; this.y=y; this.r=14; this.alive=true; }
      update(dt){ /* no-op for now; reserved for flicker/bob */ }
      draw(){
        if (!this.alive) return;
        ctx.fillStyle = '#cc2a2a';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, TAU); ctx.fill();
        // fire glyph
        ctx.fillStyle = '#ffec7a';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y-6);
        ctx.quadraticCurveTo(this.x+5, this.y-2, this.x+1, this.y+3);
        ctx.quadraticCurveTo(this.x-4, this.y+1, this.x, this.y-6);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.25)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r-1, 0, TAU); ctx.stroke();
      }
    }

    class Explosion{
      constructor(x,y){ this.x=x; this.y=y; this.ttl=0.4; this.elapsed=0; this.r0=12; this.r1=300; }
      update(dt){ this.elapsed += dt; this.ttl -= dt; }
      draw(){
        const t = clamp(this.elapsed/0.4, 0, 1);
        const r = this.r0 + (this.r1 - this.r0)*t;
        const alpha = 0.55 * (1 - t);
        const grad = ctx.createRadialGradient(this.x, this.y, r*0.2, this.x, this.y, r);
        grad.addColorStop(0, `rgba(255,230,120,${alpha})`);
        grad.addColorStop(0.4, `rgba(255,120,20,${alpha*0.8})`);
        grad.addColorStop(1, 'rgba(255,80,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, TAU); ctx.fill();
      }
    }

    function triggerExplosion(x,y){
      state.explosions.push(new Explosion(x,y));
      state.shake = Math.max(state.shake, 14);
      audio.explosion();
      // scorch mark
      state.scorches.push(new Scorch(x,y));
      // damage zombies only
      const R = 300;
      for (const z of state.zombies){
        const dx = z.x - x, dy = z.y - y; const d2 = dx*dx+dy*dy;
        if (d2 < R*R){
          const d = Math.sqrt(d2);
          const fall = 1 - d/R;
          z.hurt(140 + 160*fall);
        }
      }
      // chain to nearby barrels
      const chainR = 110;
      for (let i=state.barrels.length-1; i>=0; i--){
        const br = state.barrels[i];
        const dx = br.x - x, dy = br.y - y;
        if (dx*dx + dy*dy <= chainR*chainR){
          state.barrels.splice(i,1);
          triggerExplosion(br.x, br.y);
        }
      }
    }

    function initBarrels(){
      state.barrels.length = 0;
      const cx = state.w*0.5, cy = state.h*0.5;
      const R = Math.max(120, Math.min(state.w, state.h)*0.3);
      const count = randInt(8, 10);
      let tries = 0;
      while (state.barrels.length < count && tries < 60){
        tries++;
        const theta = rand(0, TAU);
        const dist = R + rand(-40, 60);
        const x = cx + Math.cos(theta)*dist;
        const y = cy + Math.sin(theta)*dist;
        const b = new Barrel(x,y);
        // avoid overlapping player spawn and covers
        if (Math.hypot(x-cx, y-cy) < 60) continue;
        let bad=false;
        for (const c of state.covers){ if (Math.hypot(x-c.cx, y-c.cy) < b.r + c.radius() + 8){ bad=true; break; } }
        for (const other of state.barrels){ if (Math.hypot(x-other.x, y-other.y) < b.r + other.r + 20){ bad=true; break; } }
        if (!bad) state.barrels.push(b);
      }
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // Input
    window.addEventListener('mousemove', (e) => {
      const r = canvas.getBoundingClientRect();
      state.mouse.x = e.clientX - r.left;
      state.mouse.y = e.clientY - r.top;
    });
    window.addEventListener('mousedown', () => { state.mouse.down = true; state.mouse.justPressed = true; });
    window.addEventListener('mouseup', () => { state.mouse.down = false; state.draggingCover = null; });
    window.addEventListener('blur', () => { state.keys.clear(); state.mouse.down = false; });
    window.addEventListener('keydown', (e) => {
      const code = e.code;
      // Prevent page scroll for movement keys
      if (code === 'ArrowUp' || code === 'ArrowDown' || code === 'ArrowLeft' || code === 'ArrowRight' || code === 'KeyW' || code === 'KeyA' || code === 'KeyS' || code === 'KeyD'){
        e.preventDefault();
      }
      if (code === 'KeyR') { if (!state.running) restart(); }
      state.keys.add(code);
    });
    window.addEventListener('keyup', (e) => state.keys.delete(e.code));

    // Utils
    const TAU = Math.PI*2;
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rand = (a,b)=>a + Math.random()*(b-a);
    const randInt = (a,b)=>Math.floor(rand(a,b+1));
    const length = (x,y)=>Math.hypot(x,y);
    const norm = (x,y)=>{const l=length(x,y)||1; return {x:x/l,y:y/l};}
    const dist2 = (a,b)=>{const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
    const DESPAWN_MARGIN = 60;
    const rectsOverlap = (ax,ay,aw,ah, bx,by,bw,bh)=> ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
    const dot = (ax,ay,bx,by)=> ax*bx + ay*by;
    const rot = (x,y, c,s)=>({x: c*x - s*y, y: s*x + c*y});
    const QUIPS = [
      "I'm hobo with a shotgun!",
      "Not a dinner with a shotgun!",
      "Damn, reloading!",
      "Hasta la vista, zombos!",
      "Who ordered lead salad?",
      "Brains? Not today.",
      "Boom headshot!",
      "Two for one!",
      "Keep 'em coming!",
      "This is my boomstick!",
      "No refunds!",
      "Free samples of buckshot!",
      "You shall not pass!",
      "Click-clack party.",
      "Next!",
      "Messy business.",
      "Clean-up on aisle 3!",
      "Holes need more holes!",
      "Mind the splatter.",
      "Ammo diet starts tomorrow.",
      "Stay down!",
      "You look terrible.",
      "Reloading, cover me!",
      "Tactical reposition!",
      "Keep your distance.",
      "No autographs!",
      "I hate cardio.",
      "Spicy!",
      "Knock knock!",
      "This is fine."
    ];
    function circleOBBCollision(cov, px, py, pr){
      const c = Math.cos(cov.angle), s = Math.sin(cov.angle);
      // to local space
      const lx = c*(px - cov.cx) + s*(py - cov.cy);
      const ly = -s*(px - cov.cx) + c*(py - cov.cy);
      const hx = cov.w*0.5, hy = cov.h*0.5;
      const clx = clamp(lx, -hx, hx);
      const cly = clamp(ly, -hy, hy);
      const dx = lx - clx, dy = ly - cly;
      const d2 = dx*dx + dy*dy;
      if (d2 > pr*pr) return null;
      const d = Math.sqrt(d2);
      let nxL, nyL;
      if (d > 1e-6) { nxL = dx/d; nyL = dy/d; }
      else {
        // choose axis outward
        const rx = Math.min(hx - Math.abs(lx), hy - Math.abs(ly));
        if (hx - Math.abs(lx) < hy - Math.abs(ly)) { nxL = Math.sign(lx)||1; nyL = 0; }
        else { nxL = 0; nyL = Math.sign(ly)||1; }
      }
      // to world space
      const nx = c*nxL - s*nyL;
      const ny = s*nxL + c*nyL;
      const depth = pr - d;
      // contact point world
      const cxw = cov.cx + (c*clx - s*cly);
      const cyw = cov.cy + (s*clx + c*cly);
      return {nx, ny, depth, cx: cxw, cy: cyw};
    }

    // circle-rect collision helper. Returns minimal translation vector {x,y,depth} or null
    function circleRectMTV(cx,cy,r, rx,ry,rw,rh){
      // find closest point on rect to circle center
      const nx = clamp(cx, rx, rx+rw);
      const ny = clamp(cy, ry, ry+rh);
      const dx = cx - nx, dy = cy - ny;
      const d2 = dx*dx + dy*dy;
      if (d2 === 0){
        // center is inside rectangle; push out along smallest axis
        const left = Math.abs(cx - rx);
        const right = Math.abs(rx+rw - cx);
        const top = Math.abs(cy - ry);
        const bottom = Math.abs(ry+rh - cy);
        const m = Math.min(left,right,top,bottom);
        if (m === left) return {x: -(r), y: 0, depth: r};
        if (m === right) return {x: r, y: 0, depth: r};
        if (m === top) return {x: 0, y: -(r), depth: r};
        return {x: 0, y: r, depth: r};
      }
      if (d2 < r*r){
        const d = Math.sqrt(d2);
        const pen = r - d;
        const nxv = dx / (d||1);
        const nyv = dy / (d||1);
        return {x: nxv*pen, y: nyv*pen, depth: pen};
      }
      return null;
    }

    // Simple WebAudio synth for SFX (no external files)
    const audio = {
      ctx: null,
      ensure(){
        if (!this.ctx){
          const AC = window.AudioContext || window.webkitAudioContext;
          if (!AC) return;
          this.ctx = new AC();
        }
      },
      resume(){ if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); },
      shot(){
        this.ensure(); if (!this.ctx) return;
        const ctx = this.ctx; const now = ctx.currentTime;
        const dur = 0.22 + Math.random()*0.05;
        // main body noise
        const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate*dur), ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
        const src = ctx.createBufferSource(); src.buffer = buffer;
        const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 1300 + Math.random()*500; bp.Q.value = 0.7;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 2100 + Math.random()*300; lp.Q.value = 0.32;
        // soft clip shaper for fatter transient
        const shaper = ctx.createWaveShaper();
        const curve = new Float32Array(256); for (let i=0;i<256;i++){ const x=i/255*2-1; curve[i] = Math.tanh(3.6*x); } shaper.curve = curve; shaper.oversample='2x';
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(1.75, now+0.007); g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
        src.connect(bp); bp.connect(lp); lp.connect(shaper); shaper.connect(g); g.connect(ctx.destination);
        src.start(now); src.stop(now+dur);
        // transient click layer
        const src2 = ctx.createBufferSource(); src2.buffer = buffer;
        const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 1800; hp.Q.value = 0.7;
        const gClick = ctx.createGain(); gClick.gain.setValueAtTime(0.0001, now); gClick.gain.exponentialRampToValueAtTime(0.5, now+0.004); gClick.gain.exponentialRampToValueAtTime(0.0001, now+0.05);
        src2.connect(hp); hp.connect(gClick); gClick.connect(ctx.destination);
        src2.start(now); src2.stop(now+0.06);
        // double low thump + sub tail
        const osc = ctx.createOscillator(); osc.type='sine';
        osc.frequency.setValueAtTime(110, now);
        osc.frequency.exponentialRampToValueAtTime(52, now+0.11);
        const g2 = ctx.createGain(); g2.gain.setValueAtTime(0.0001, now); g2.gain.exponentialRampToValueAtTime(0.8, now+0.004); g2.gain.exponentialRampToValueAtTime(0.0001, now+0.14);
        osc.connect(g2); g2.connect(ctx.destination); osc.start(now); osc.stop(now+0.12);
        const osc2 = ctx.createOscillator(); osc2.type='triangle';
        osc2.frequency.setValueAtTime(70, now);
        osc2.frequency.exponentialRampToValueAtTime(48, now+0.1);
        const g3 = ctx.createGain(); g3.gain.setValueAtTime(0.0001, now); g3.gain.exponentialRampToValueAtTime(0.42, now+0.006); g3.gain.exponentialRampToValueAtTime(0.0001, now+0.11);
        osc2.connect(g3); g3.connect(ctx.destination); osc2.start(now); osc2.stop(now+0.11);
        // metallic ping (tiny)
        const ping = ctx.createOscillator(); ping.type='triangle';
        ping.frequency.setValueAtTime(1500, now+0.01);
        ping.frequency.exponentialRampToValueAtTime(750, now+0.06);
        const gPing = ctx.createGain(); gPing.gain.setValueAtTime(0.0001, now+0.01); gPing.gain.exponentialRampToValueAtTime(0.24, now+0.015); gPing.gain.exponentialRampToValueAtTime(0.0001, now+0.07);
        ping.connect(gPing); gPing.connect(ctx.destination); ping.start(now+0.01); ping.stop(now+0.08);
        // second, lower ping for heavier metal
        const ping2 = ctx.createOscillator(); ping2.type='square';
        ping2.frequency.setValueAtTime(800, now+0.018);
        ping2.frequency.exponentialRampToValueAtTime(520, now+0.06);
        const gPing2 = ctx.createGain(); gPing2.gain.setValueAtTime(0.0001, now+0.018); gPing2.gain.exponentialRampToValueAtTime(0.18, now+0.022); gPing2.gain.exponentialRampToValueAtTime(0.0001, now+0.08);
        ping2.connect(gPing2); gPing2.connect(ctx.destination); ping2.start(now+0.018); ping2.stop(now+0.085);
        // sub-bass tail
        const sub = ctx.createOscillator(); sub.type='sine';
        sub.frequency.setValueAtTime(48, now+0.015);
        sub.frequency.exponentialRampToValueAtTime(36, now+0.2);
        const gSub = ctx.createGain(); gSub.gain.setValueAtTime(0.0001, now+0.015); gSub.gain.exponentialRampToValueAtTime(0.22, now+0.03); gSub.gain.exponentialRampToValueAtTime(0.0001, now+0.22);
        sub.connect(gSub); gSub.connect(ctx.destination); sub.start(now+0.015); sub.stop(now+0.24);
      },
      hit(){
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        // wet slap noise
        const dur = 0.07;
        const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate*dur), ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
        const src = ctx.createBufferSource(); src.buffer = buffer;
        const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 900; bp.Q.value = 1.0;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 1400; lp.Q.value = 0.7;
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.55, now+0.004); g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
        src.connect(bp); bp.connect(lp); lp.connect(g); g.connect(ctx.destination);
        src.start(now); src.stop(now+dur);
        // short thud
        const osc = ctx.createOscillator(); osc.type='sine';
        osc.frequency.setValueAtTime(220, now);
        osc.frequency.exponentialRampToValueAtTime(120, now+0.06);
        const g2 = ctx.createGain(); g2.gain.setValueAtTime(0.0001, now); g2.gain.exponentialRampToValueAtTime(0.35, now+0.003); g2.gain.exponentialRampToValueAtTime(0.0001, now+0.08);
        osc.connect(g2); g2.connect(ctx.destination); osc.start(now); osc.stop(now+0.08);
      },
      hurt(){
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        const osc = ctx.createOscillator(); osc.type='sawtooth';
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.35, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.18);
        osc.frequency.setValueAtTime(250, now);
        osc.frequency.exponentialRampToValueAtTime(120, now+0.18);
        osc.connect(g); g.connect(ctx.destination); osc.start(now); osc.stop(now+0.19);
      },
      kill(){
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        const osc = ctx.createOscillator(); osc.type='triangle';
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.25, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
        osc.frequency.setValueAtTime(160, now);
        osc.frequency.exponentialRampToValueAtTime(90, now+0.12);
        osc.connect(g); g.connect(ctx.destination); osc.start(now); osc.stop(now+0.13);
      },
      reload(){
        // DOOM-like bolt rack: two hard mechanical clacks, minimal swish
        this.ensure(); if (!this.ctx) return;
        const ctx = this.ctx; const now = ctx.currentTime;
        // Helper: short metallic clack
        const makeClack = (t, metalGain, thudGain, hiFreqStart, hiFreqEnd) => {
          // metallic ping
          const ping = ctx.createOscillator(); ping.type='triangle';
          const gP = ctx.createGain(); gP.gain.setValueAtTime(0.0001, t); gP.gain.exponentialRampToValueAtTime(metalGain, t+0.01); gP.gain.exponentialRampToValueAtTime(0.0001, t+0.14);
          ping.frequency.setValueAtTime(hiFreqStart*0.8, t); ping.frequency.exponentialRampToValueAtTime(hiFreqEnd*0.7, t+0.09);
          ping.connect(gP); gP.connect(ctx.destination); ping.start(t); ping.stop(t+0.13);
          // short noise tick
          const dur = 0.06; const buf = ctx.createBuffer(1, Math.floor(ctx.sampleRate*dur), ctx.sampleRate);
          const d = buf.getChannelData(0); for (let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * (1 - i/d.length);
          const src = ctx.createBufferSource(); src.buffer = buf; const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 900; hp.Q.value = 0.9;
          const gN = ctx.createGain(); gN.gain.setValueAtTime(0.0001, t); gN.gain.exponentialRampToValueAtTime(metalGain*0.1, t+0.008); gN.gain.exponentialRampToValueAtTime(0.0001, t+dur);
          src.connect(hp); hp.connect(gN); gN.connect(ctx.destination); src.start(t); src.stop(t+dur);
          // body thud
          const th = ctx.createOscillator(); th.type='sine';
          const gT = ctx.createGain(); gT.gain.setValueAtTime(0.0001, t+0.005); gT.gain.exponentialRampToValueAtTime(thudGain, t+0.012); gT.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
          th.frequency.setValueAtTime(160, t+0.005); th.frequency.exponentialRampToValueAtTime(180, t+0.1);
          th.connect(gT); gT.connect(ctx.destination); th.start(t+0.005); th.stop(t+0.11);
        };
        // First clack ‚Äî 'zhchik' (lower, noisy, juicy)
        makeClack(now, 0.4, 0.34, 100, 900);
        // Second clack ‚Äî 'chin' (higher, with ring)
        makeClack(now+0.09, 0.62, 0.38, 1600, 1400);
      },
      reloadMag(){
        // Longer reload gesture for refilling magazine
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        const noiseDur = 0.25;
        const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate*noiseDur), ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
        const src = ctx.createBufferSource(); src.buffer = buffer;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 900; lp.Q.value = 0.7;
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.25, now+0.02); g.gain.exponentialRampToValueAtTime(0.0001, now+0.26);
        src.connect(lp); lp.connect(g); g.connect(ctx.destination); src.start(now); src.stop(now+0.26);
        // metallic click
        const osc = ctx.createOscillator(); osc.type='triangle';
        const g2 = ctx.createGain(); g2.gain.setValueAtTime(0.0001, now+0.18); g2.gain.exponentialRampToValueAtTime(0.2, now+0.2); g2.gain.exponentialRampToValueAtTime(0.0001, now+0.32);
        osc.frequency.setValueAtTime(700, now+0.18);
        osc.connect(g2); g2.connect(ctx.destination); osc.start(now+0.18); osc.stop(now+0.33);
      },
      splat(){
        // Wet smash for zombie death
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        // noise burst lowpassed + pitch down thump
        const dur = 0.18;
        const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate*dur), ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
        const src = ctx.createBufferSource(); src.buffer = buffer;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 500; lp.Q.value = 0.9;
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.6, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
        src.connect(lp); lp.connect(g); g.connect(ctx.destination); src.start(now); src.stop(now+dur);
        // thump
        const osc = ctx.createOscillator(); osc.type='sine';
        const g2 = ctx.createGain(); g2.gain.setValueAtTime(0.0001, now); g2.gain.exponentialRampToValueAtTime(0.35, now+0.005); g2.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
        osc.frequency.setValueAtTime(180, now);
        osc.frequency.exponentialRampToValueAtTime(90, now+0.1);
        osc.connect(g2); g2.connect(ctx.destination); osc.start(now); osc.stop(now+0.13);
      },
      explosion(){
        // Big boom: noise burst + low thump + echo tail
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        const dur = 0.42;
        const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate*dur), ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length) * 0.9;
        const src = ctx.createBufferSource(); src.buffer = buffer;
        const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 800; bp.Q.value = 0.4;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 1000; lp.Q.value = 0.7;
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(1.5, now+0.012); g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
        // echo tail (feedback delay with damping)
        const delay = ctx.createDelay(0.6); delay.delayTime.value = 0.22;
        const fb = ctx.createGain(); fb.gain.value = 0.32;
        const damp = ctx.createBiquadFilter(); damp.type='lowpass'; damp.frequency.value = 1200; damp.Q.value = 0.3;
        lp.connect(delay); delay.connect(damp); damp.connect(fb); fb.connect(delay);
        const out = ctx.createGain(); out.gain.value = 1.0;
        delay.connect(out);
        src.connect(bp); bp.connect(lp); lp.connect(g); g.connect(ctx.destination); g.connect(delay);
        src.start(now); src.stop(now+dur);
        // deeper low boom
        const osc = ctx.createOscillator(); osc.type='sine';
        const g2 = ctx.createGain(); g2.gain.setValueAtTime(0.0001, now); g2.gain.exponentialRampToValueAtTime(0.65, now+0.02); g2.gain.exponentialRampToValueAtTime(0.0001, now+0.45);
        osc.frequency.setValueAtTime(120, now); osc.frequency.exponentialRampToValueAtTime(48, now+0.42);
        osc.connect(g2); g2.connect(ctx.destination); g2.connect(delay);
        osc.start(now); osc.stop(now+0.46);
      },
      gameOver(){
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        const osc = ctx.createOscillator(); osc.type='sine';
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.25, now+0.02); g.gain.exponentialRampToValueAtTime(0.0001, now+0.5);
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(220, now+0.25);
        osc.connect(g); g.connect(ctx.destination); osc.start(now); osc.stop(now+0.5);
      }
    };

    function initAudioOnGesture(){
      const boot = () => { audio.ensure(); audio.resume(); };
      window.addEventListener('mousedown', boot, {once:true});
      window.addEventListener('keydown', boot, {once:true});
      window.addEventListener('touchstart', boot, {once:true, passive:true});
    }
    initAudioOnGesture();

    class Player {
      constructor(x,y){
        this.x=x; this.y=y;
        this.r = 18;
        this.speed = 260;
        this.hp = 100;
        this.fireCooldown = 0;
        this.fireRate = 0.28; // seconds between shots
        this.recoil = 0;
        this.damageCooldown = 0; // i-frames
        this.reloadSfxTimer = 0;
        // Magazine
        this.magSize = 6;
        this.ammo = this.magSize;
        this.reloading = false;
        this.reloadTimer = 0;
        this.reloadDuration = 1.0; // seconds to refill magazine
        // movement velocity for pushing
        this.moveVx = 0; this.moveVy = 0;
        // Weapon core stats
        this.baseDamage = 70;
        this.damageMul = 1.0;
        this.pelletsBase = 7;
        this.pelletBonus = 0;
        this.bulletSpeedBase = 1200;
        this.bulletSpeedMul = 1.0;
        this.stopLevel = 0; // stopping power level
        this.slowFactorBase = 0.6;
        this.slowDurationBase = 0.6;
        // Visuals (combine additively)
        this.barrelCount = 1;
        this.barrelLength = 14; // added to radius
        this.barrelThickness = 6;
        this.coolTier = 0; // 0..n for cosmetic extras
        // Upgrade levels (0..5)
        this.damageLevel = 0;
        this.pelletsLevel = 0;
        this.speedLevel = 0;
      }
      update(dt){
        // Movement
        let ax=0, ay=0;
        if (state.keys.has('KeyW') || state.keys.has('ArrowUp')) ay -= 1;
        if (state.keys.has('KeyS') || state.keys.has('ArrowDown')) ay += 1;
        if (state.keys.has('KeyA') || state.keys.has('ArrowLeft')) ax -= 1;
        if (state.keys.has('KeyD') || state.keys.has('ArrowRight')) ax += 1;
        if (ax || ay){
          const m = norm(ax,ay);
          this.moveVx = m.x*this.speed;
          this.moveVy = m.y*this.speed;
          this.x += m.x*this.speed*dt;
          this.y += m.y*this.speed*dt;
        } else { this.moveVx = 0; this.moveVy = 0; }
        // Clamp to screen
        this.x = clamp(this.x, this.r, state.w - this.r);
        this.y = clamp(this.y, this.r, state.h - this.r);

        // Aim
        this.aim = Math.atan2(state.mouse.y - this.y, state.mouse.x - this.x);

        // Shooting (click-to-shoot, no autofire on hold)
        this.fireCooldown -= dt;
        if (state.mouse.justPressed && this.fireCooldown <= 0 && state.running && !this.reloading && this.ammo > 0){
          this.shoot();
          this.fireCooldown = this.fireRate;
        }
        // consume click each frame, even if on cooldown
        state.mouse.justPressed = false;

        // Damage cooldown
        this.damageCooldown = Math.max(0, this.damageCooldown - dt);

        // Recoil decay
        this.recoil *= Math.pow(0.001, dt); // fast decay
        // Reload SFX timing
        if (this.reloadSfxTimer > 0){
          this.reloadSfxTimer -= dt;
          if (this.reloadSfxTimer <= 0) audio.reload();
        }
        // Magazine reload logic
        if (this.ammo <= 0 && !this.reloading){
          this.startReload();
        }
        if (this.reloading){
          this.reloadTimer -= dt;
          if (this.reloadTimer <= 0){
            this.ammo = this.magSize;
            this.reloading = false;
          }
        }
      }
      shoot(){
        const basePellets = this.pelletsBase + this.pelletBonus;
        const pellets = Math.max(3, basePellets + randInt(-1, 1));
        const spreadBase = 0.15;
        const spread = spreadBase * rand(0.8, 1.3);
        const speed = this.bulletSpeedBase * this.bulletSpeedMul;
        const dmg = this.baseDamage * this.damageMul;
        const slowFactor = Math.max(0.2, this.slowFactorBase - 0.06 * this.stopLevel);
        const slowDuration = this.slowDurationBase + 0.12 * this.stopLevel;
        const aimOffset = rand(-0.04, 0.04);
        const baseAim = this.aim + aimOffset;

        for (let i=0;i<pellets;i++){
          const a = baseAim + rand(-spread, spread);
          const vx = Math.cos(a)*speed;
          const vy = Math.sin(a)*speed;
          const px = this.x + Math.cos(this.aim)*this.r*0.8;
          const py = this.y + Math.sin(this.aim)*this.r*0.8;
          state.bullets.push(new Bullet(px,py,vx,vy, dmg, slowFactor, slowDuration));
        }
        // Recoil and screen shake
        this.recoil += 1;
        state.shake = Math.min(10, state.shake + 3);
        // Sound
        audio.shot();
        // schedule reload sfx
        this.reloadSfxTimer = Math.min(0.25, this.fireRate * 0.6);
        // consume ammo
        this.ammo = Math.max(0, this.ammo - 1);
        // quip trigger every N shots
        state.shotsFired += 1;
        if (state.shotsFired >= state.nextQuipAt){
          const text = QUIPS[randInt(0, QUIPS.length-1)];
          state.quips.push({text, ttl: 2.6, age: 0});
          state.nextQuipAt += randInt(30,50);
          // keep at most 3 lines
          while (state.quips.length > 3) state.quips.shift();
        }
        // auto-start reload if empty
        if (this.ammo === 0) this.startReload();
      }
      startReload(){
        if (this.reloading) return;
        this.reloading = true;
        this.reloadTimer = this.reloadDuration;
        audio.reloadMag();
      }
      hurt(amount){
        if (this.damageCooldown>0) return;
        this.hp -= amount;
        this.damageCooldown = 0.6;
        state.shake = Math.min(12, state.shake + 4);
        audio.hurt();
        if (this.hp <= 0){
          gameOver();
        }
      }
      draw(){
        // Player body
        ctx.save();
        // subtle recoil offset
        const rx = -Math.cos(this.aim)*this.recoil*2;
        const ry = -Math.sin(this.aim)*this.recoil*2;
        ctx.translate(rx, ry);

        // glow
        ctx.fillStyle = '#14161c';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r+6, 0, TAU);
        ctx.fill();

        // body
        ctx.fillStyle = '#3aa3ff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, TAU);
        ctx.fill();

        // shotgun barrels (visual upgrades combined)
        const L = this.r + this.barrelLength;
        const lw = this.barrelThickness;
        const c = Math.cos(this.aim), s = Math.sin(this.aim);
        const px = -s, py = c; // perpendicular
        const count = Math.max(1, this.barrelCount);
        const gap = 6; // spacing between barrels
        for (let i=0;i<count;i++){
          const t = (i - (count-1)/2) * gap;
          const ox = this.x + px * t;
          const oy = this.y + py * t;
          // color depends on coolTier
          const hue = Math.min(200, 160 + this.coolTier*10);
          ctx.strokeStyle = `hsl(${hue}, 80%, 85%)`;
          ctx.lineWidth = lw;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(ox, oy);
          ctx.lineTo(ox + c*L, oy + s*L);
          ctx.stroke();
          // small muzzle brake fins if coolTier
          if (this.coolTier>0){
            ctx.strokeStyle = `rgba(255,255,255,${0.15 + 0.08*this.coolTier})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(ox + c*(L-6) + px*3, oy + s*(L-6) + py*3);
            ctx.lineTo(ox + c*L + px*5, oy + s*L + py*5);
            ctx.moveTo(ox + c*(L-6) - px*3, oy + s*(L-6) - py*3);
            ctx.lineTo(ox + c*L - px*5, oy + s*L - py*5);
            ctx.stroke();
          }
        }

        // eye
        ctx.fillStyle = '#0b1020';
        ctx.beginPath();
        ctx.arc(this.x + Math.cos(this.aim)*8,
                this.y + Math.sin(this.aim)*8, 3, 0, TAU);
        ctx.fill();

        ctx.restore();
      }
    }

    class Splat{
      constructor(x,y){
        this.x=x; this.y=y;
        this.ttl = 60.5; // seconds
        this.blobs = [];
        const n = randInt(8,14);
        for (let i=0;i<n;i++){
          const a = rand(0, TAU);
          const d = rand(2, 22);
          const r = rand(2, 8);
          this.blobs.push({x: this.x + Math.cos(a)*d, y: this.y + Math.sin(a)*d, r});
        }
      }
      update(dt){ this.ttl -= dt; }
      draw(){
        const t = Math.max(0, Math.min(1, this.ttl/3.5));
        const alpha = 0.65 * t;
        // dark undercoat
        ctx.fillStyle = `rgba(80,0,0,${alpha})`;
        for (const b of this.blobs){
          ctx.beginPath(); ctx.arc(b.x+1, b.y+1, b.r*1.1, 0, TAU); ctx.fill();
        }
        // bright blood
        ctx.fillStyle = `rgba(160,10,10,${alpha})`;
        for (const b of this.blobs){
          ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, TAU); ctx.fill();
        }
      }
    }

    class Bullet{
      constructor(x,y,vx,vy, dmg, slowFactor, slowDuration){
        this.x=x; this.y=y; this.vx=vx; this.vy=vy;
        this.px=x; this.py=y; // previous position for trail
        this.r=3; // collision radius (visual tip is smaller)
        this.dmg=dmg;
        this.slowFactor = slowFactor;
        this.slowDuration = slowDuration;
      }
      update(dt){
        this.px = this.x; this.py = this.y;
        this.x += this.vx*dt;
        this.y += this.vy*dt;
      }
      draw(){
        // trail line
        const ang = Math.atan2(this.vy, this.vx);
        const len = 14; // constant trail length
        const tx = this.x - Math.cos(ang)*len;
        const ty = this.y - Math.sin(ang)*len;
        ctx.strokeStyle = 'rgba(255,209,102,0.9)';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(tx, ty);
        ctx.lineTo(this.x, this.y);
        ctx.stroke();
        // small bright tip
        ctx.fillStyle = '#ffe6a3';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 1.2, 0, TAU);
        ctx.fill();
      }
    }

    class Zombie{
      constructor(x,y, hp, speed, tier, coverDmgRate, scale, id, visLevel){
        this.x=x; this.y=y;
        this.tier = Math.max(0, Math.floor(tier||0));
        this.scale = scale || 1;
        this.id = (id==null? 0 : id)|0;
        this.visLevel = Math.max(0, Math.floor(visLevel||0));
        // size scales sublinearly with visual level to avoid absurd growth
        const sizeMul = 1 + 0.14 * Math.sqrt(this.visLevel);
        this.r = 18 * this.scale * (1 + 0.08*this.tier) * sizeMul;
        this.hp=hp;
        this.speed=speed;
        this.baseSpeed = speed;
        this.coverDmgRate = coverDmgRate || 20;
        this.hurtTimer = 0;
        // slow effect
        this.slowMul = 1; // 1 = no slow; <1 = slowed
        this.slowTimer = 0;
        // rng per zombie for consistent cosmetic jitter
        this.rand = mulberry32((this.id*1664525 + 1013904223)>>>0);
      }
      update(dt){
        // Move towards player
        const dx = state.player.x - this.x;
        const dy = state.player.y - this.y;
        const m = norm(dx,dy);
        // update slow timer
        if (this.slowTimer > 0){ this.slowTimer -= dt; if (this.slowTimer <= 0) { this.slowMul = 1; } }
        const sp = this.baseSpeed * this.slowMul;
        this.x += m.x*sp*dt;
        this.y += m.y*sp*dt;
        if (this.hurtTimer>0) this.hurtTimer -= dt;

        // If touches player
        const rr = (this.r + state.player.r);
        if (dist2(this, state.player) < rr*rr){
          state.player.hurt(12);
          // small knockback
          this.x -= m.x*12;
          this.y -= m.y*12;
        }
      }
      hurt(dmg){
        this.hp -= dmg;
        this.hurtTimer = 0.1;
      }
      applySlow(factor, duration){
        // factor in (0,1], duration in seconds
        this.slowMul = Math.min(this.slowMul, Math.max(0.2, factor));
        this.slowTimer = Math.max(this.slowTimer, duration);
      }
      draw(){
        // base color: shift hue/darken with level
        const hue = 120 - Math.min(60, this.visLevel*3); // 120..60
        const light = 60 - Math.min(25, this.visLevel*2); // 60..35
        const fillCol = this.hurtTimer>0 ? 'hsl(120,80%,80%)' : `hsl(${hue}, 45%, ${light}%)`;
        // body
        ctx.fillStyle = fillCol;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, TAU);
        ctx.fill();

        // head spikes proportional to visLevel (capped)
        const spikes = Math.min(18, Math.floor(this.visLevel/2));
        if (spikes>0){
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.lineWidth = Math.max(1, this.r*0.04);
          const base = this.rand();
          for (let i=0;i<spikes;i++){
            const ang = (i/spikes)*TAU*0.9 + base*0.4; // not full circle to keep face clean
            const sx = this.x + Math.cos(ang)*this.r;
            const sy = this.y + Math.sin(ang)*this.r;
            const ex = this.x + Math.cos(ang)*(this.r + 6 + this.visLevel*0.8);
            const ey = this.y + Math.sin(ang)*(this.r + 6 + this.visLevel*0.8);
            ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
          }
        }

        // eyes: become narrower and angrier with level
        const eBase = Math.max(2, this.r*0.12);
        const squint = Math.min(0.7, this.visLevel*0.06);
        const eyeW = eBase*(1.2 + 0.1*this.tier);
        const eyeH = eBase*(1 - squint);
        ctx.fillStyle = '#0b1020';
        // left eye
        ctx.save();
        ctx.translate(this.x - this.r*0.28, this.y - this.r*0.15);
        ctx.rotate(-0.15 - squint*0.3);
        ctx.beginPath(); ctx.ellipse(0,0, eyeW, eyeH, 0, 0, TAU); ctx.fill();
        ctx.restore();
        // right eye
        ctx.save();
        ctx.translate(this.x + this.r*0.28, this.y - this.r*0.13);
        ctx.rotate(0.15 + squint*0.3);
        ctx.beginPath(); ctx.ellipse(0,0, eyeW, eyeH, 0, 0, TAU); ctx.fill();
        ctx.restore();

        // mouth and teeth count scale with level
        const mouthW = Math.max(10, this.r*0.9);
        const mouthH = Math.max(4, this.r*0.18);
        const mx = this.x - mouthW*0.5, my = this.y + this.r*0.15;
        // dark mouth cavity
        ctx.fillStyle = `rgba(0,0,0,0.55)`;
        ctx.fillRect(mx, my, mouthW, mouthH);
        // teeth as triangles along top and bottom
        const teeth = Math.min(24, 2 + Math.floor(this.visLevel*0.8));
        ctx.fillStyle = '#fff';
        for (let i=0;i<teeth;i++){
          const t = (i+0.5)/teeth;
          const tx = mx + t*mouthW;
          const jitter = (this.rand()-0.5)*2;
          const hTop = mouthH*0.7*(0.7 + 0.3*(this.rand()));
          // top tooth
          ctx.beginPath();
          ctx.moveTo(tx-2, my);
          ctx.lineTo(tx+2, my);
          ctx.lineTo(tx + jitter, my - hTop);
          ctx.closePath(); ctx.fill();
          // bottom tooth (every second for density)
          if (i%2===0){
            const hBot = mouthH*0.55*(0.7 + 0.3*(this.rand()));
            ctx.beginPath();
            ctx.moveTo(tx-2, my+mouthH);
            ctx.lineTo(tx+2, my+mouthH);
            ctx.lineTo(tx + jitter*0.6, my+mouthH + hBot);
            ctx.closePath(); ctx.fill();
          }
        }
      }
    }

    function spawnOneZombie(weak){
      // Spawn one zombie just outside one of the edges
      let edge;
      if (weak){
        // First weak wave ‚Äî strictly from one chosen side; later weak waves biased ~80%
        if (state.zombiesSpawned === 0) edge = state.weakSide;
        else edge = (Math.random() < 0.8) ? state.weakSide : randInt(0,3);
      } else {
        edge = randInt(0,3); // 0 top,1 right,2 bottom,3 left
      }
      const margin = 40;
      let x,y;
      if (edge===0){ x = rand(-margin, state.w+margin); y = -margin; }
      else if (edge===2){ x = rand(-margin, state.w+margin); y = state.h+margin; }
      else if (edge===1){ x = state.w+margin; y = rand(-margin, state.h+margin); }
      else { x = -margin; y = rand(-margin, state.h+margin); }
      if (weak){
        const hp = rand(25, 50);
        const sp = rand(70, 110);
        const scale = rand(0.85, 1.0);
        const vis = Math.max(0, Math.floor(state.wave*0.6) + randInt(0,1));
        const z = new Zombie(x,y,hp, sp, 0, 6, scale, ++state.zombieId, vis);
        state.zombies.push(z);
      } else {
        const t = state.time;
        const tier = Math.min(3, Math.floor(t/40));
        const hp = 110 + t*4 + tier*30;
        const sp = clamp(90 + t*0.9 + tier*5, 90, 180);
        const scale = 1.0 + tier*0.05;
        const coverDmg = 18 + tier*10;
        const vis = Math.max(1,
          Math.floor(state.wave) + tier*2 + (state.endlessMode ? Math.floor(state.time/60) : 0)
        );
        const z = new Zombie(x,y,hp, sp, tier, coverDmg, scale, ++state.zombieId, vis);
        state.zombies.push(z);
      }
      state.zombiesSpawned += 1;
    }

    function spawnWave(){
      // Endless mode: spawn continuously without cap
      if (state.endlessMode){
        spawnOneZombie(false);
        return;
      }
      // stop spawning if wave cap reached
      if (state.zombiesSpawned >= state.waveCap){ state.waveCapped = true; return; }
      if (state.weakPhase){
        const leftWeak = Math.max(0, 100 - state.zombiesSpawned);
        const leftToCap = Math.max(0, state.waveCap - state.zombiesSpawned);
        const n = Math.min(leftWeak, leftToCap, randInt(3,7));
        for (let i=0;i<n;i++) spawnOneZombie(true);
        if (state.zombiesSpawned >= 100) state.weakPhase = false;
      } else {
        if (state.zombiesSpawned < state.waveCap) spawnOneZombie(false);
      }
      if (state.zombiesSpawned >= state.waveCap) state.waveCapped = true;
    }

    function gameOver(){
      state.running = false;
      overlay.classList.add('show');
      final.textContent = '–°—á—ë—Ç: ' + state.score;
      audio.gameOver();
    }

    function restart(){
      state.score = 0;
      state.time = 0;
      state.spawnTimer = 10; // delay first zombie spawn by 10s
      state.spawnInterval = 1.1;
      state.zombiesSpawned = 0;
      state.weakPhase = true;
      state.weakSide = randInt(0,3); // choose a side for weak horde
      state.wave = 1;
      state.waveCap = getWaveCap(state.wave);
      state.waveCapped = false;
      state.endlessShown = false;
      state.endlessMode = false;
      state.bullets.length = 0;
      state.zombies.length = 0;
      state.splats.length = 0;
      state.explosions.length = 0;
      state.barrels.length = 0;
      state.quips.length = 0;
      state.shotsFired = 0;
      state.nextQuipAt = randInt(30,50);
      state.covers.length = 0;
      initCovers();
      state.player = new Player(state.w*0.5, state.h*0.5);
      state.phase = 'fight';
      state.running = true;
      overlay.classList.remove('show');
      if (upgOverlay) upgOverlay.classList.remove('show');
      uiScore.textContent = 'Score: 0';
      uiHP.textContent = 'HP: 100';
    }

    function initCovers(){
      // Build a partial circular ring around the player with gaps, plus a few extra blocks nearby
      const cx = state.w*0.5, cy = state.h*0.5;
      const R = Math.max(120, Math.min(state.w, state.h)*0.25);
      const segments = 12;
      const thickness = 22;
      const segLen = 90;
      // choose gap indices
      const gapCount = 3;
      const gapIdx = new Set();
      while (gapIdx.size < gapCount){ gapIdx.add(randInt(0, segments-1)); }
      for (let i=0;i<segments;i++){
        if (gapIdx.has(i)) continue; // leave a hole
        const theta = (i/segments)*Math.PI*2;
        const ang = theta + Math.PI*0.5; // tangent orientation
        const rcx = cx + Math.cos(theta)*R;
        const rcy = cy + Math.sin(theta)*R;
        const w = segLen * rand(0.9, 1.1);
        const h = thickness * rand(0.9, 1.1);
        const x = rcx - w*0.5;
        const y = rcy - h*0.5;
        const hp = Math.floor(260 + (w*h)/18);
        const cov = new Cover(x,y,w,h,hp);
        cov.angle = ang;
        state.covers.push(cov);
      }
      // Add a few extra blocks near gaps so player can slide them to close holes
      for (const gi of gapIdx){
        const theta = (gi/segments)*Math.PI*2;
        for (let k=0;k<2;k++){
          const offset = (k===0? -1 : 1) * rand(40, 80);
          const rcx = cx + Math.cos(theta)*(R + offset);
          const rcy = cy + Math.sin(theta)*(R + offset);
          const ang = theta + Math.PI*0.5;
          const w = rand(60, 90);
          const h = rand(18, 26);
          const x = rcx - w*0.5;
          const y = rcy - h*0.5;
          const hp = Math.floor(230 + (w*h)/20);
          const cov = new Cover(x,y,w,h,hp);
          cov.angle = ang;
          state.covers.push(cov);
        }
      }
      // place explosive barrels after covers are placed
      initBarrels();
    }

    function update(dt){
      state.time += dt;
      // Increase difficulty
      state.spawnInterval = clamp(1.1 - state.time*0.0015, 0.32, 1.1);
      // Spawning always while running
      state.spawnTimer -= dt;
      if (state.spawnTimer <= 0 && state.running){
        if (!state.waveCapped) {
          spawnWave();
        }
        state.spawnTimer = state.spawnInterval;
      }

      // Mark covers as not pushed this frame
      for (const c of state.covers) c.pushed = false;

      state.player.update(dt);
      // Player pushes covers with impulse on OBB contact
      for (let k=0; k<state.covers.length; k++){
        const c = state.covers[k];
        const col = circleOBBCollision(c, state.player.x, state.player.y, state.player.r);
        if (col){
          // positional correction (split between player and cover)
          const sep = col.depth + 1e-3;
          const playerShare = 0.35;
          const coverShare = 1 - playerShare;
          state.player.x += col.nx * (sep * playerShare);
          state.player.y += col.ny * (sep * playerShare);
          c.cx -= col.nx * (sep * coverShare);
          c.cy -= col.ny * (sep * coverShare);
          c.pushed = true;
          // impulse based on player's movement into normal
          const mvx = state.player.moveVx, mvy = state.player.moveVy;
          const mvLen = Math.hypot(mvx, mvy);
          const dirx = mvLen ? mvx/mvLen : 0, diry = mvLen ? mvy/mvLen : 0;
          const into = Math.max(0, dirx*col.nx + diry*col.ny);
          const J = (900 + 900*into) * dt * (mvLen / state.player.speed);
          const rpx = col.cx - c.cx; const rpy = col.cy - c.cy;
          c.vx += col.nx * (J * c.invMass);
          c.vy += col.ny * (J * c.invMass);
          c.clampToBounds();
          // avoid overlaps with other covers via circle bounds, revert if overlapping badly
          for (let m=0; m<state.covers.length; m++){
            if (m===k) continue;
            const o = state.covers[m];
            if (Math.hypot(c.cx - o.cx, c.cy - o.cy) < c.radius() + o.radius() - 6){
              c.cx += col.nx * (sep * coverShare); c.cy += col.ny * (sep * coverShare);
              c.vx *= 0.3; c.vy *= 0.3;
              break;
            }
          }
          // extra resolve pass to ensure player is fully outside the cover
          const col2 = circleOBBCollision(c, state.player.x, state.player.y, state.player.r);
          if (col2){
            const sep2 = col2.depth + 0.5;
            state.player.x += col2.nx * sep2;
            state.player.y += col2.ny * sep2;
          }
        }
      }

      // Update bullets and check barrel hits
      for (let i=state.bullets.length-1; i>=0; i--){
        const b = state.bullets[i];
        b.update(dt);
        // hit barrels
        let exploded = false;
        for (let bi=state.barrels.length-1; bi>=0; bi--){
          const br = state.barrels[bi];
          if (!br.alive) continue;
          const rr = br.r + b.r;
          const dx = b.x - br.x, dy = b.y - br.y;
          if (dx*dx + dy*dy <= rr*rr){
            br.alive = false;
            state.barrels.splice(bi,1);
            triggerExplosion(br.x, br.y);
            state.bullets.splice(i,1);
            exploded = true;
            break;
          }
        }
        if (exploded) continue;
        // Despawn beyond map bounds
        if (b.x < -DESPAWN_MARGIN || b.y < -DESPAWN_MARGIN || b.x > state.w + DESPAWN_MARGIN || b.y > state.h + DESPAWN_MARGIN){
          state.bullets.splice(i,1);
        }
      }

      // Update zombies and collisions
      for (let i=state.zombies.length-1; i>=0; i--){
        const z = state.zombies[i];
        z.update(dt);
        // resolve zombie collisions with OBB covers and damage them
        for (let k=state.covers.length-1; k>=0; k--){
          const c = state.covers[k];
          const col = circleOBBCollision(c, z.x, z.y, z.r);
          if (col){
            // push zombie out along normal
            z.x += col.nx * col.depth; z.y += col.ny * col.depth;
            // damage cover gradually
            c.hp -= (z.coverDmgRate||20)*dt;
            if (c.hp <= 0){ state.covers.splice(k,1); continue; }
          }
        }
        // bullets collide
        for (let j=state.bullets.length-1; j>=0; j--){
          const b = state.bullets[j];
          const rr = (z.r + b.r);
          if (dist2(z, b) < rr*rr){
            z.hurt(b.dmg);
            // apply slow based on bullet params
            if (typeof z.applySlow === 'function') {
              const f = (b.slowFactor!=null? b.slowFactor : 0.6);
              const d = (b.slowDuration!=null? b.slowDuration : 0.6);
              z.applySlow(f, d);
            }
            audio.hit();
            state.bullets.splice(j,1);
          }
        }
        if (z.hp <= 0){
          state.zombies.splice(i,1);
          state.score += 1;
          // splat effect
          state.splats.push(new Splat(z.x, z.y));
          audio.splat();
        }
      }

      // Update explosions
      for (let i=state.explosions.length-1; i>=0; i--){
        const e = state.explosions[i];
        e.update(dt);
        if (e.ttl <= 0) state.explosions.splice(i,1);
      }

      // Update scorches
      for (let i=state.scorches.length-1; i>=0; i--){
        const s = state.scorches[i];
        s.update(dt);
        if (s.ttl <= 0) state.scorches.splice(i,1);
      }

      // Update splats (fade and cleanup)
      for (let i=state.splats.length-1; i>=0; i--){
        const s = state.splats[i];
        s.update(dt);
        if (s.ttl <= 0) state.splats.splice(i,1);
      }

      // Update quips
      for (let i=state.quips.length-1; i>=0; i--){
        const q = state.quips[i];
        q.age = (q.age||0) + dt;
        q.ttl -= dt;
        if (q.ttl <= 0) state.quips.splice(i,1);
      }

      // Update barrels
      for (let i=state.barrels.length-1; i>=0; i--){
        const br = state.barrels[i];
        br.update(dt);
        if (!br.alive) state.barrels.splice(i,1);
      }
      // Update covers AFTER handling all collisions/pushes; stop if not pushed
      for (const c of state.covers){
        if (!c.pushed){ c.vx = 0; c.vy = 0; c.av = 0; }
        c.integrate(dt);
      }
      // UI updates
      uiScore.textContent = 'Score: ' + state.score;
      uiHP.textContent = 'HP: ' + clamp(Math.ceil(state.player.hp),0,999);
      if (state.player){
        const mag = state.player.magSize || 0;
        const ammo = clamp(state.player.ammo, 0, mag);
        let icons = '';
        for (let i=0;i<mag;i++){
          if (i < ammo) icons += 'üîã';
          else icons += '<span style="opacity:.25">üîã</span>';
        }
        uiAmmo.innerHTML = 'Ammo: ' + icons + (state.player.reloading ? ' <span class="hint">(reload...)</span>' : '');
      } else {
        uiAmmo.textContent = 'Ammo: ';
      }
      if (state.spawnTimer > 0){
        uiCountdown.textContent = '–î–æ –∞—Ç–∞–∫–∏: ' + Math.max(0, state.spawnTimer).toFixed(1) + 's';
      } else {
        uiCountdown.textContent = '';
      }

      // screen shake
      state.shake = Math.max(0, state.shake - 40*dt);

      // Wave completion -> open upgrade menu
      if (state.running && state.waveCapped && state.zombies.length === 0){
        showUpgrade();
      }
    }

    function render(){
      // background
      const shakeX = state.shake ? rand(-state.shake, state.shake) : 0;
      const shakeY = state.shake ? rand(-state.shake, state.shake) : 0;
      ctx.save();
      ctx.translate(shakeX, shakeY);
      ctx.fillRect(-100,-100, state.w+200, state.h+200);

      // subtle grid
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.lineWidth = 1;
      const grid = 40;
      for (let x= (state.time*20)%grid; x<state.w; x+=grid){
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,state.h); ctx.stroke();
      }
      for (let y= (state.time*12)%grid; y<state.h; y+=grid){
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(state.w,y); ctx.stroke();
      }

      // Entities
      for (const s of state.splats) s.draw();
      for (const sc of state.scorches) sc.draw();
      // covers
      for (const c of state.covers) c.draw();
      // barrels
      for (const br of state.barrels) br.draw();
      for (const b of state.bullets) b.draw();
      for (const z of state.zombies) z.draw();
      // explosions overlay
      for (const e of state.explosions) e.draw();
      state.player.draw();

      // quips above player
      if (state.quips.length){
        const baseY = state.player.y - state.player.r - 26;
        ctx.font = '16px monospace';
        ctx.textAlign = 'center';
        for (let i=0;i<state.quips.length;i++){
          const q = state.quips[i];
          const y = baseY - i*18 - (q.age||0)*8;
          const alpha = Math.min(1, Math.max(0, q.ttl/2));
          ctx.strokeStyle = `rgba(0,0,0,${0.7*alpha})`;
          ctx.lineWidth = 3; ctx.lineJoin='round';
          ctx.strokeText(q.text, state.player.x, y);
          ctx.fillStyle = `rgba(255,255,255,${alpha})`;
          ctx.fillText(q.text, state.player.x, y);
        }
      }

      ctx.restore();

      // crosshair
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(state.mouse.x, state.mouse.y, 10, 0, TAU);
      ctx.moveTo(state.mouse.x-14, state.mouse.y);
      ctx.lineTo(state.mouse.x-4, state.mouse.y);
      ctx.moveTo(state.mouse.x+14, state.mouse.y);
      ctx.lineTo(state.mouse.x+4, state.mouse.y);
      ctx.moveTo(state.mouse.x, state.mouse.y-14);
      ctx.lineTo(state.mouse.x, state.mouse.y-4);
      ctx.moveTo(state.mouse.x, state.mouse.y+14);
      ctx.lineTo(state.mouse.x, state.mouse.y+4);
      ctx.stroke();
    }

    // Main loop
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now - last)/1000);
      last = now;
      if (state.player) {
        if (state.running) update(dt);
        render();
      }
      requestAnimationFrame(loop);
    }

    // Start
    restart();
    requestAnimationFrame(loop);

    // Upgrades & Waves
    function isAllMaxed(){
      const p = state.player; if (!p) return false;
      const MAX=5;
      return (p.damageLevel>=MAX && p.pelletsLevel>=MAX && p.speedLevel>=MAX && p.stopLevel>=MAX);
    }
    function showUpgrade(){
      state.running = false;
      state.phase = 'upgrade';
      if (upgOverlay) upgOverlay.classList.add('show');
      updateUpgradeUI();
    }
    function applyUpgrade(kind){
      const p = state.player; if (!p) return;
      const MAX=5;
      if (kind === 'damage'){
        if (p.damageLevel >= MAX) return;
        p.damageLevel += 1;
        p.damageMul *= 1.6; // +50% per level
        p.barrelThickness = Math.min(12, p.barrelThickness + 1.2);
      } else if (kind === 'stopping'){
        if (p.stopLevel >= MAX) return;
        p.stopLevel = Math.min(MAX, p.stopLevel + 1);
        p.barrelLength = Math.min(32, p.barrelLength + 2);
      } else if (kind === 'speed'){
        if (p.speedLevel >= MAX) return;
        p.speedLevel += 1;
        p.bulletSpeedMul *= 1.15;
        p.coolTier = Math.min(MAX, p.speedLevel);
      } else if (kind === 'pellets'){
        if (p.pelletsLevel >= MAX) return;
        p.pelletsLevel += 1;
        p.pelletBonus += 7;
        p.barrelCount = Math.min(4, 1 + p.pelletsLevel);
      }
      updateUpgradeUI();
      if (isAllMaxed() && !state.endlessShown){
        state.quips.push({text: '–î–µ—Ä–∏—Å—å –¥–æ –∫–æ–Ω—Ü–∞!', ttl: 6.5, age: 0});
        state.endlessShown = true;
      }
      startNextWave();
    }
    function updateUpgradeUI(){
      const p = state.player; if (!p) return;
      const MAX=5;
      const set = (btn, bar, lbl, val) => {
        if (lbl) lbl.textContent = `${val}/${MAX}`;
        if (bar) bar.style.width = `${Math.min(100, (val/MAX)*100)}%`;
        if (btn) btn.disabled = (val >= MAX);
      };
      set(btnDamage, barDamage, lblDamage, p.damageLevel||0);
      set(btnStopping, barStopping, lblStopping, p.stopLevel||0);
      set(btnSpeed, barSpeed, lblSpeed, p.speedLevel||0);
      set(btnPellets, barPellets, lblPellets, p.pelletsLevel||0);
      if (btnEndless) btnEndless.style.display = isAllMaxed() ? 'block' : 'none';
    }
    function startNextWave(){
      if (upgOverlay) upgOverlay.classList.remove('show');
      state.wave += 1;
      state.score = 0; // reset score between waves
      state.zombiesSpawned = 0;
      state.waveCapped = false;
      state.weakPhase = true;
      state.weakSide = randInt(0,3);
      state.spawnTimer = 2.0;
      state.waveCap = getWaveCap(state.wave);
      // regen player hp and rebuild covers & barrels
      if (state.player) state.player.hp = 100;
      state.covers.length = 0;
      initCovers();
      state.phase = 'fight';
      state.running = true;
    }
    function startEndless(){
      if (upgOverlay) upgOverlay.classList.remove('show');
      state.endlessMode = true;
      state.waveCapped = false;
      state.zombiesSpawned = 0;
      state.spawnTimer = 2.0;
      state.score = 0; // reset score for endless
      // regen player hp and rebuild covers & barrels
      if (state.player) state.player.hp = 100;
      state.covers.length = 0;
      initCovers();
      state.phase = 'fight';
      state.running = true;
      if (!state.endlessShown){
        state.quips.push({text: '–î–µ—Ä–∏—Å—å –¥–æ –∫–æ–Ω—Ü–∞!', ttl: 6.5, age: 0});
        state.endlessShown = true;
      }
    }
  })();
  </script>
</body>
</html>
