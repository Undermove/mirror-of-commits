<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Topdown Shooter: Zombies</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0f0f12; color: #e6e6e6; font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    canvas { display: block; width: 100vw; height: 100vh; cursor: crosshair; }
    #ui { position: fixed; left: 16px; top: 12px; z-index: 10; user-select: none; }
    #ui .stat { font-weight: 700; font-size: 14px; line-height: 1.2; margin-bottom: 6px; }
    #ui .hint { opacity: .7; font-size: 12px; }

    .overlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,.5); z-index: 20; }
    .overlay.show { display: flex; }
    .panel { background: rgba(20,20,26,.9); padding: 24px 28px; border: 1px solid rgba(255,255,255,.1); border-radius: 12px; text-align: center; box-shadow: 0 8px 30px rgba(0,0,0,.6); }
    .panel h1 { margin: 0 0 8px; font-size: 24px; }
    .panel p { margin: 6px 0 0; opacity: .85; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="stat" id="score">Score: 0</div>
    <div class="stat" id="health">HP: 100</div>
    <div class="stat" id="ammo">Ammo: </div>
    <div class="stat" id="countdown"></div>
    <div class="hint">WASD: движение • Мышь: прицел • ЛКМ: стрелять • R: рестарт</div>
  </div>
  <canvas id="game"></canvas>

  <div class="overlay" id="gameover">
    <div class="panel">
      <h1>Вы померли. Зомби сожрали ваши мозги</h1>
      <p id="final">Счёт: 0</p>
      <p>Нажмите R для рестарта</p>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const uiScore = document.getElementById('score');
    const uiHP = document.getElementById('health');
    const uiAmmo = document.getElementById('ammo');
    const uiCountdown = document.getElementById('countdown');
    const overlay = document.getElementById('gameover');
    const final = document.getElementById('final');

    const state = {
      w: 0, h: 0, dpr: window.devicePixelRatio || 1,
      running: true,
      score: 0,
      time: 0,
      spawnTimer: 0,
      spawnInterval: 1.1,
      keys: new Set(),
      mouse: {x: 0, y: 0, down: false, justPressed: false},
      bullets: [],
      zombies: [],
      splats: [],
      explosions: [],
      barrels: [],
      quips: [],
      scorches: [],
      covers: [],
      draggingCover: null,
      phase: 'fight', // always fight; covers are pushed physically
      zombiesSpawned: 0,
      weakPhase: true,
      weakSide: 0,
      shotsFired: 0,
      nextQuipAt: 35,
      player: null,
      shake: 0
    };

    function resize() {
      state.dpr = window.devicePixelRatio || 1;
      state.w = Math.max(320, window.innerWidth);
      state.h = Math.max(240, window.innerHeight);
      canvas.width = Math.floor(state.w * state.dpr);
      canvas.height = Math.floor(state.h * state.dpr);
      ctx.setTransform(state.dpr,0,0,state.dpr,0,0);
    }

    class Cover{
      constructor(x,y,w,h, hp){
        // x,y as top-left for init; store as center with rotation and velocities
        this.cx = x + w*0.5; this.cy = y + h*0.5; this.w=w; this.h=h;
        this.angle = Math.random()*Math.PI*2;
        this.vx = 0; this.vy = 0; this.av = 0;
        const area = w*h; const density = 0.002;
        this.mass = Math.max(1, density*area);
        this.invMass = 1/this.mass;
        const I = (this.mass*(w*w + h*h))/12;
        this.inertia = Math.max(1e-3, I);
        this.invInertia = 1/this.inertia;
        this.hp = hp; this.maxHp = hp;
      }
      radius(){ return Math.hypot(this.w, this.h)*0.5; }
      clampToBounds(){
        const r = this.radius();
        this.cx = clamp(this.cx, r, state.w - r);
        this.cy = clamp(this.cy, r, state.h - r);
      }
      integrate(dt){
        this.cx += this.vx*dt; this.cy += this.vy*dt; // keep angle fixed (no rotation)
        // small friction (damping) — медленное затухание (линейная), без угловой инерции
        const linD = Math.pow(0.9, dt);  // ~0.9 за секунду
        this.vx *= linD; this.vy *= linD; this.av = 0;
        this.clampToBounds();
      }
      draw(){
        const t = clamp(this.hp/this.maxHp, 0, 1);
        const base = 40 + Math.floor(60*t);
        ctx.save();
        ctx.translate(this.cx, this.cy);
        ctx.rotate(this.angle);
        ctx.fillStyle = `rgb(${base},${base},${base})`;
        ctx.fillRect(-this.w*0.5, -this.h*0.5, this.w, this.h);
        // outline
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 2;
        ctx.strokeRect(-this.w*0.5+0.5, -this.h*0.5+0.5, this.w-1, this.h-1);
        ctx.restore();
        // hp bar above
        ctx.fillStyle = 'rgba(200,40,40,0.8)';
        ctx.fillRect(this.cx - this.w*0.5, this.cy - this.h*0.5 - 8, this.w*t, 4);
      }
    }

    class Scorch{
      constructor(x,y){ this.x=x; this.y=y; this.r=70; this.ttl=18; }
      update(dt){ this.ttl -= dt; }
      draw(){
        const t = Math.max(0, Math.min(1, this.ttl/18));
        const alpha = 0.25 * t;
        const grad = ctx.createRadialGradient(this.x, this.y, 10, this.x, this.y, this.r);
        grad.addColorStop(0, `rgba(0,0,0,${alpha})`);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, TAU); ctx.fill();
      }
    }

    class Barrel{
      constructor(x,y){ this.x=x; this.y=y; this.r=14; this.alive=true; }
      update(dt){ /* no-op for now; reserved for flicker/bob */ }
      draw(){
        if (!this.alive) return;
        ctx.fillStyle = '#cc2a2a';
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, TAU); ctx.fill();
        // fire glyph
        ctx.fillStyle = '#ffec7a';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y-6);
        ctx.quadraticCurveTo(this.x+5, this.y-2, this.x+1, this.y+3);
        ctx.quadraticCurveTo(this.x-4, this.y+1, this.x, this.y-6);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.25)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r-1, 0, TAU); ctx.stroke();
      }
    }

    class Explosion{
      constructor(x,y){ this.x=x; this.y=y; this.ttl=0.4; this.elapsed=0; this.r0=12; this.r1=300; }
      update(dt){ this.elapsed += dt; this.ttl -= dt; }
      draw(){
        const t = clamp(this.elapsed/0.4, 0, 1);
        const r = this.r0 + (this.r1 - this.r0)*t;
        const alpha = 0.55 * (1 - t);
        const grad = ctx.createRadialGradient(this.x, this.y, r*0.2, this.x, this.y, r);
        grad.addColorStop(0, `rgba(255,230,120,${alpha})`);
        grad.addColorStop(0.4, `rgba(255,120,20,${alpha*0.8})`);
        grad.addColorStop(1, 'rgba(255,80,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, TAU); ctx.fill();
      }
    }

    function triggerExplosion(x,y){
      state.explosions.push(new Explosion(x,y));
      state.shake = Math.max(state.shake, 14);
      audio.explosion();
      // scorch mark
      state.scorches.push(new Scorch(x,y));
      // damage zombies only
      const R = 300;
      for (const z of state.zombies){
        const dx = z.x - x, dy = z.y - y; const d2 = dx*dx+dy*dy;
        if (d2 < R*R){
          const d = Math.sqrt(d2);
          const fall = 1 - d/R;
          z.hurt(140 + 160*fall);
        }
      }
      // chain to nearby barrels
      const chainR = 110;
      for (let i=state.barrels.length-1; i>=0; i--){
        const br = state.barrels[i];
        const dx = br.x - x, dy = br.y - y;
        if (dx*dx + dy*dy <= chainR*chainR){
          state.barrels.splice(i,1);
          triggerExplosion(br.x, br.y);
        }
      }
    }

    function initBarrels(){
      state.barrels.length = 0;
      const cx = state.w*0.5, cy = state.h*0.5;
      const R = Math.max(120, Math.min(state.w, state.h)*0.3);
      const count = randInt(8, 30);
      let tries = 0;
      while (state.barrels.length < count && tries < 60){
        tries++;
        const theta = rand(0, TAU);
        const dist = R + rand(-40, 60);
        const x = cx + Math.cos(theta)*dist;
        const y = cy + Math.sin(theta)*dist;
        const b = new Barrel(x,y);
        // avoid overlapping player spawn and covers
        if (Math.hypot(x-cx, y-cy) < 60) continue;
        let bad=false;
        for (const c of state.covers){ if (Math.hypot(x-c.cx, y-c.cy) < b.r + c.radius() + 8){ bad=true; break; } }
        for (const other of state.barrels){ if (Math.hypot(x-other.x, y-other.y) < b.r + other.r + 20){ bad=true; break; } }
        if (!bad) state.barrels.push(b);
      }
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // Input
    window.addEventListener('mousemove', (e) => {
      const r = canvas.getBoundingClientRect();
      state.mouse.x = e.clientX - r.left;
      state.mouse.y = e.clientY - r.top;
    });
    window.addEventListener('mousedown', () => { state.mouse.down = true; state.mouse.justPressed = true; });
    window.addEventListener('mouseup', () => { state.mouse.down = false; state.draggingCover = null; });
    window.addEventListener('blur', () => { state.keys.clear(); state.mouse.down = false; });
    window.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if (k === 'r') { if (!state.running) restart(); }
      state.keys.add(k);
    });
    window.addEventListener('keyup', (e) => state.keys.delete(e.key.toLowerCase()));

    // Utils
    const TAU = Math.PI*2;
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rand = (a,b)=>a + Math.random()*(b-a);
    const randInt = (a,b)=>Math.floor(rand(a,b+1));
    const length = (x,y)=>Math.hypot(x,y);
    const norm = (x,y)=>{const l=length(x,y)||1; return {x:x/l,y:y/l};}
    const dist2 = (a,b)=>{const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
    const DESPAWN_MARGIN = 60;
    const rectsOverlap = (ax,ay,aw,ah, bx,by,bw,bh)=> ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
    const dot = (ax,ay,bx,by)=> ax*bx + ay*by;
    const rot = (x,y, c,s)=>({x: c*x - s*y, y: s*x + c*y});
    const QUIPS = [
      "I'm hobo with a shotgun!",
      "Not a dinner with a shotgun!",
      "Damn, reloading!",
      "Hasta la vista, zombos!",
      "Who ordered lead salad?",
      "Brains? Not today.",
      "Boom headshot!",
      "Two for one!",
      "Keep 'em coming!",
      "This is my boomstick!",
      "No refunds!",
      "Free samples of buckshot!",
      "You shall not pass!",
      "Click-clack party.",
      "Next!",
      "Messy business.",
      "Clean-up on aisle 3!",
      "Holes need more holes!",
      "Mind the splatter.",
      "Ammo diet starts tomorrow.",
      "Stay down!",
      "You look terrible.",
      "Reloading, cover me!",
      "Tactical reposition!",
      "Keep your distance.",
      "No autographs!",
      "I hate cardio.",
      "Spicy!",
      "Knock knock!",
      "This is fine."
    ];
    function circleOBBCollision(cov, px, py, pr){
      const c = Math.cos(cov.angle), s = Math.sin(cov.angle);
      // to local space
      const lx = c*(px - cov.cx) + s*(py - cov.cy);
      const ly = -s*(px - cov.cx) + c*(py - cov.cy);
      const hx = cov.w*0.5, hy = cov.h*0.5;
      const clx = clamp(lx, -hx, hx);
      const cly = clamp(ly, -hy, hy);
      const dx = lx - clx, dy = ly - cly;
      const d2 = dx*dx + dy*dy;
      if (d2 > pr*pr) return null;
      const d = Math.sqrt(d2);
      let nxL, nyL;
      if (d > 1e-6) { nxL = dx/d; nyL = dy/d; }
      else {
        // choose axis outward
        const rx = Math.min(hx - Math.abs(lx), hy - Math.abs(ly));
        if (hx - Math.abs(lx) < hy - Math.abs(ly)) { nxL = Math.sign(lx)||1; nyL = 0; }
        else { nxL = 0; nyL = Math.sign(ly)||1; }
      }
      // to world space
      const nx = c*nxL - s*nyL;
      const ny = s*nxL + c*nyL;
      const depth = pr - d;
      // contact point world
      const cxw = cov.cx + (c*clx - s*cly);
      const cyw = cov.cy + (s*clx + c*cly);
      return {nx, ny, depth, cx: cxw, cy: cyw};
    }

    // circle-rect collision helper. Returns minimal translation vector {x,y,depth} or null
    function circleRectMTV(cx,cy,r, rx,ry,rw,rh){
      // find closest point on rect to circle center
      const nx = clamp(cx, rx, rx+rw);
      const ny = clamp(cy, ry, ry+rh);
      const dx = cx - nx, dy = cy - ny;
      const d2 = dx*dx + dy*dy;
      if (d2 === 0){
        // center is inside rectangle; push out along smallest axis
        const left = Math.abs(cx - rx);
        const right = Math.abs(rx+rw - cx);
        const top = Math.abs(cy - ry);
        const bottom = Math.abs(ry+rh - cy);
        const m = Math.min(left,right,top,bottom);
        if (m === left) return {x: -(r), y: 0, depth: r};
        if (m === right) return {x: r, y: 0, depth: r};
        if (m === top) return {x: 0, y: -(r), depth: r};
        return {x: 0, y: r, depth: r};
      }
      if (d2 < r*r){
        const d = Math.sqrt(d2);
        const pen = r - d;
        const nxv = dx / (d||1);
        const nyv = dy / (d||1);
        return {x: nxv*pen, y: nyv*pen, depth: pen};
      }
      return null;
    }

    // Simple WebAudio synth for SFX (no external files)
    const audio = {
      ctx: null,
      ensure(){
        if (!this.ctx){
          const AC = window.AudioContext || window.webkitAudioContext;
          if (!AC) return;
          this.ctx = new AC();
        }
      },
      resume(){ if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); },
      shot(){
        this.ensure(); if (!this.ctx) return;
        const ctx = this.ctx; const now = ctx.currentTime;
        const dur = 0.22 + Math.random()*0.05;
        // main body noise
        const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate*dur), ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
        const src = ctx.createBufferSource(); src.buffer = buffer;
        const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 1300 + Math.random()*500; bp.Q.value = 0.7;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 2600 + Math.random()*600; lp.Q.value = 0.25;
        // soft clip shaper for fatter transient
        const shaper = ctx.createWaveShaper();
        const curve = new Float32Array(256); for (let i=0;i<256;i++){ const x=i/255*2-1; curve[i] = Math.tanh(2.6*x); } shaper.curve = curve; shaper.oversample='2x';
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(1.35, now+0.007); g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
        src.connect(bp); bp.connect(lp); lp.connect(shaper); shaper.connect(g); g.connect(ctx.destination);
        src.start(now); src.stop(now+dur);
        // transient click layer
        const src2 = ctx.createBufferSource(); src2.buffer = buffer;
        const hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = 1800; hp.Q.value = 0.7;
        const gClick = ctx.createGain(); gClick.gain.setValueAtTime(0.0001, now); gClick.gain.exponentialRampToValueAtTime(0.5, now+0.004); gClick.gain.exponentialRampToValueAtTime(0.0001, now+0.05);
        src2.connect(hp); hp.connect(gClick); gClick.connect(ctx.destination);
        src2.start(now); src2.stop(now+0.06);
        // double low thump
        const osc = ctx.createOscillator(); osc.type='sine';
        osc.frequency.setValueAtTime(140, now);
        osc.frequency.exponentialRampToValueAtTime(65, now+0.09);
        const g2 = ctx.createGain(); g2.gain.setValueAtTime(0.0001, now); g2.gain.exponentialRampToValueAtTime(0.55, now+0.004); g2.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
        osc.connect(g2); g2.connect(ctx.destination); osc.start(now); osc.stop(now+0.12);
        const osc2 = ctx.createOscillator(); osc2.type='triangle';
        osc2.frequency.setValueAtTime(90, now);
        osc2.frequency.exponentialRampToValueAtTime(55, now+0.08);
        const g3 = ctx.createGain(); g3.gain.setValueAtTime(0.0001, now); g3.gain.exponentialRampToValueAtTime(0.28, now+0.006); g3.gain.exponentialRampToValueAtTime(0.0001, now+0.1);
        osc2.connect(g3); g3.connect(ctx.destination); osc2.start(now); osc2.stop(now+0.11);
        // metallic ping (tiny)
        const ping = ctx.createOscillator(); ping.type='triangle';
        ping.frequency.setValueAtTime(1800, now+0.01);
        ping.frequency.exponentialRampToValueAtTime(900, now+0.06);
        const gPing = ctx.createGain(); gPing.gain.setValueAtTime(0.0001, now+0.01); gPing.gain.exponentialRampToValueAtTime(0.12, now+0.015); gPing.gain.exponentialRampToValueAtTime(0.0001, now+0.07);
        ping.connect(gPing); gPing.connect(ctx.destination); ping.start(now+0.01); ping.stop(now+0.08);
      },
      hit(){
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        // wet slap noise
        const dur = 0.07;
        const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate*dur), ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
        const src = ctx.createBufferSource(); src.buffer = buffer;
        const bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value = 900; bp.Q.value = 1.0;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 1400; lp.Q.value = 0.7;
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.55, now+0.004); g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
        src.connect(bp); bp.connect(lp); lp.connect(g); g.connect(ctx.destination);
        src.start(now); src.stop(now+dur);
        // short thud
        const osc = ctx.createOscillator(); osc.type='sine';
        osc.frequency.setValueAtTime(220, now);
        osc.frequency.exponentialRampToValueAtTime(120, now+0.06);
        const g2 = ctx.createGain(); g2.gain.setValueAtTime(0.0001, now); g2.gain.exponentialRampToValueAtTime(0.35, now+0.003); g2.gain.exponentialRampToValueAtTime(0.0001, now+0.08);
        osc.connect(g2); g2.connect(ctx.destination); osc.start(now); osc.stop(now+0.08);
      },
      hurt(){
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        const osc = ctx.createOscillator(); osc.type='sawtooth';
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.35, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.18);
        osc.frequency.setValueAtTime(250, now);
        osc.frequency.exponentialRampToValueAtTime(120, now+0.18);
        osc.connect(g); g.connect(ctx.destination); osc.start(now); osc.stop(now+0.19);
      },
      kill(){
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        const osc = ctx.createOscillator(); osc.type='triangle';
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.25, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
        osc.frequency.setValueAtTime(160, now);
        osc.frequency.exponentialRampToValueAtTime(90, now+0.12);
        osc.connect(g); g.connect(ctx.destination); osc.start(now); osc.stop(now+0.13);
      },
      reload(){
        this.ensure(); if (!this.ctx) return;
        const ctx = this.ctx; const now = ctx.currentTime;
        // Stage A: pull back "chik" — swish + click
        const durA = 0.11;
        const bufA = ctx.createBuffer(1, Math.floor(ctx.sampleRate*durA), ctx.sampleRate);
        const dA = bufA.getChannelData(0); for (let i=0;i<dA.length;i++) dA[i] = (Math.random()*2-1) * (1 - i/dA.length);
        const a = ctx.createBufferSource(); a.buffer = bufA;
        const aHP = ctx.createBiquadFilter(); aHP.type='highpass'; aHP.frequency.value = 900; aHP.Q.value = 0.8;
        const aG = ctx.createGain(); aG.gain.setValueAtTime(0.0001, now); aG.gain.exponentialRampToValueAtTime(0.35, now+0.02); aG.gain.exponentialRampToValueAtTime(0.0001, now+durA);
        a.connect(aHP); aHP.connect(aG); aG.connect(ctx.destination); a.start(now); a.stop(now+durA);
        const aClick = ctx.createOscillator(); aClick.type='square';
        const aCG = ctx.createGain(); aCG.gain.setValueAtTime(0.0001, now+0.02); aCG.gain.exponentialRampToValueAtTime(0.25, now+0.03); aCG.gain.exponentialRampToValueAtTime(0.0001, now+0.09);
        aClick.frequency.setValueAtTime(1200, now+0.02);
        aClick.connect(aCG); aCG.connect(ctx.destination); aClick.start(now+0.02); aClick.stop(now+0.1);
        // Stage B: push forward "chak" — heavier swish + metal clack
        const tB = now + 0.12;
        const durB = 0.12;
        const bufB = ctx.createBuffer(1, Math.floor(ctx.sampleRate*durB), ctx.sampleRate);
        const dB = bufB.getChannelData(0); for (let i=0;i<dB.length;i++) dB[i] = (Math.random()*2-1) * (1 - i/dB.length);
        const b = ctx.createBufferSource(); b.buffer = bufB;
        const bBP = ctx.createBiquadFilter(); bBP.type='bandpass'; bBP.frequency.value = 1000; bBP.Q.value = 0.9;
        const bG = ctx.createGain(); bG.gain.setValueAtTime(0.0001, tB); bG.gain.exponentialRampToValueAtTime(0.45, tB+0.02); bG.gain.exponentialRampToValueAtTime(0.0001, tB+durB);
        b.connect(bBP); bBP.connect(bG); bG.connect(ctx.destination); b.start(tB); b.stop(tB+durB);
        // metal clack
        const cl = ctx.createOscillator(); cl.type='triangle';
        const clG = ctx.createGain(); clG.gain.setValueAtTime(0.0001, tB+0.04); clG.gain.exponentialRampToValueAtTime(0.35, tB+0.045); clG.gain.exponentialRampToValueAtTime(0.0001, tB+0.15);
        cl.frequency.setValueAtTime(1500, tB+0.04); cl.frequency.exponentialRampToValueAtTime(700, tB+0.12);
        cl.connect(clG); clG.connect(ctx.destination); cl.start(tB+0.04); cl.stop(tB+0.16);
      },
      reloadMag(){
        // Longer reload gesture for refilling magazine
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        const noiseDur = 0.25;
        const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate*noiseDur), ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
        const src = ctx.createBufferSource(); src.buffer = buffer;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 900; lp.Q.value = 0.7;
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.25, now+0.02); g.gain.exponentialRampToValueAtTime(0.0001, now+0.26);
        src.connect(lp); lp.connect(g); g.connect(ctx.destination); src.start(now); src.stop(now+0.26);
        // metallic click
        const osc = ctx.createOscillator(); osc.type='triangle';
        const g2 = ctx.createGain(); g2.gain.setValueAtTime(0.0001, now+0.18); g2.gain.exponentialRampToValueAtTime(0.2, now+0.2); g2.gain.exponentialRampToValueAtTime(0.0001, now+0.32);
        osc.frequency.setValueAtTime(700, now+0.18);
        osc.connect(g2); g2.connect(ctx.destination); osc.start(now+0.18); osc.stop(now+0.33);
      },
      splat(){
        // Wet smash for zombie death
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        // noise burst lowpassed + pitch down thump
        const dur = 0.18;
        const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate*dur), ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
        const src = ctx.createBufferSource(); src.buffer = buffer;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 500; lp.Q.value = 0.9;
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.6, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
        src.connect(lp); lp.connect(g); g.connect(ctx.destination); src.start(now); src.stop(now+dur);
        // thump
        const osc = ctx.createOscillator(); osc.type='sine';
        const g2 = ctx.createGain(); g2.gain.setValueAtTime(0.0001, now); g2.gain.exponentialRampToValueAtTime(0.35, now+0.005); g2.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
        osc.frequency.setValueAtTime(180, now);
        osc.frequency.exponentialRampToValueAtTime(90, now+0.1);
        osc.connect(g2); g2.connect(ctx.destination); osc.start(now); osc.stop(now+0.13);
      },
      explosion(){
        // Big boom: noise burst + low thump
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        const dur = 0.35;
        const buffer = ctx.createBuffer(1, Math.floor(ctx.sampleRate*dur), ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length) * 0.9;
        const src = ctx.createBufferSource(); src.buffer = buffer;
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 1200; lp.Q.value = 0.6;
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(1.3, now+0.015); g.gain.exponentialRampToValueAtTime(0.0001, now+dur);
        src.connect(lp); lp.connect(g); g.connect(ctx.destination); src.start(now); src.stop(now+dur);
        const osc = ctx.createOscillator(); osc.type='sine';
        const g2 = ctx.createGain(); g2.gain.setValueAtTime(0.0001, now); g2.gain.exponentialRampToValueAtTime(0.5, now+0.02); g2.gain.exponentialRampToValueAtTime(0.0001, now+0.25);
        osc.frequency.setValueAtTime(140, now); osc.frequency.exponentialRampToValueAtTime(60, now+0.22);
        osc.connect(g2); g2.connect(ctx.destination); osc.start(now); osc.stop(now+0.26);
      },
      gameOver(){
        this.ensure(); if (!this.ctx) return;
        const ctx=this.ctx; const now=ctx.currentTime;
        const osc = ctx.createOscillator(); osc.type='sine';
        const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.25, now+0.02); g.gain.exponentialRampToValueAtTime(0.0001, now+0.5);
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(220, now+0.25);
        osc.connect(g); g.connect(ctx.destination); osc.start(now); osc.stop(now+0.5);
      }
    };

    function initAudioOnGesture(){
      const boot = () => { audio.ensure(); audio.resume(); };
      window.addEventListener('mousedown', boot, {once:true});
      window.addEventListener('keydown', boot, {once:true});
      window.addEventListener('touchstart', boot, {once:true, passive:true});
    }
    initAudioOnGesture();

    class Player {
      constructor(x,y){
        this.x=x; this.y=y;
        this.r = 18;
        this.speed = 260;
        this.hp = 100;
        this.fireCooldown = 0;
        this.fireRate = 0.28; // seconds between shots
        this.recoil = 0;
        this.damageCooldown = 0; // i-frames
        this.reloadSfxTimer = 0;
        // Magazine
        this.magSize = 6;
        this.ammo = this.magSize;
        this.reloading = false;
        this.reloadTimer = 0;
        this.reloadDuration = 1.0; // seconds to refill magazine
        // movement velocity for pushing
        this.moveVx = 0; this.moveVy = 0;
      }
      update(dt){
        // Movement
        let ax=0, ay=0;
        if (state.keys.has('w') || state.keys.has('arrowup')) ay -= 1;
        if (state.keys.has('s') || state.keys.has('arrowdown')) ay += 1;
        if (state.keys.has('a') || state.keys.has('arrowleft')) ax -= 1;
        if (state.keys.has('d') || state.keys.has('arrowright')) ax += 1;
        if (ax || ay){
          const m = norm(ax,ay);
          this.moveVx = m.x*this.speed;
          this.moveVy = m.y*this.speed;
          this.x += m.x*this.speed*dt;
          this.y += m.y*this.speed*dt;
        } else { this.moveVx = 0; this.moveVy = 0; }
        // Clamp to screen
        this.x = clamp(this.x, this.r, state.w - this.r);
        this.y = clamp(this.y, this.r, state.h - this.r);

        // Aim
        this.aim = Math.atan2(state.mouse.y - this.y, state.mouse.x - this.x);

        // Shooting (click-to-shoot, no autofire on hold)
        this.fireCooldown -= dt;
        if (state.mouse.justPressed && this.fireCooldown <= 0 && state.running && !this.reloading && this.ammo > 0){
          this.shoot();
          this.fireCooldown = this.fireRate;
        }
        // consume click each frame, even if on cooldown
        state.mouse.justPressed = false;

        // Damage cooldown
        this.damageCooldown = Math.max(0, this.damageCooldown - dt);

        // Recoil decay
        this.recoil *= Math.pow(0.001, dt); // fast decay
        // Reload SFX timing
        if (this.reloadSfxTimer > 0){
          this.reloadSfxTimer -= dt;
          if (this.reloadSfxTimer <= 0) audio.reload();
        }
        // Magazine reload logic
        if (this.ammo <= 0 && !this.reloading){
          this.startReload();
        }
        if (this.reloading){
          this.reloadTimer -= dt;
          if (this.reloadTimer <= 0){
            this.ammo = this.magSize;
            this.reloading = false;
          }
        }
      }
      shoot(){
        const basePellets = 7;
        const pellets = Math.max(5, basePellets + randInt(-1, 1)); // small per-shot variation
        const spreadBase = 0.15; // narrower cone
        const spread = spreadBase * rand(0.8, 1.3); // per-shot variation
        const speed = 1200; // faster bullets
        const dmg = 70; // more lethal
        const aimOffset = rand(-0.04, 0.04); // slight per-shot offset
        const baseAim = this.aim + aimOffset;

        for (let i=0;i<pellets;i++){
          const a = baseAim + rand(-spread, spread);
          const vx = Math.cos(a)*speed;
          const vy = Math.sin(a)*speed;
          const px = this.x + Math.cos(this.aim)*this.r*0.8;
          const py = this.y + Math.sin(this.aim)*this.r*0.8;
          state.bullets.push(new Bullet(px,py,vx,vy, dmg));
        }
        // Recoil and screen shake
        this.recoil += 1;
        state.shake = Math.min(10, state.shake + 3);
        // Sound
        audio.shot();
        // schedule reload sfx
        this.reloadSfxTimer = Math.min(0.25, this.fireRate * 0.6);
        // consume ammo
        this.ammo = Math.max(0, this.ammo - 1);
        // quip trigger every N shots
        state.shotsFired += 1;
        if (state.shotsFired >= state.nextQuipAt){
          const text = QUIPS[randInt(0, QUIPS.length-1)];
          state.quips.push({text, ttl: 2.6, age: 0});
          state.nextQuipAt += randInt(30,50);
          // keep at most 3 lines
          while (state.quips.length > 3) state.quips.shift();
        }
        // auto-start reload if empty
        if (this.ammo === 0) this.startReload();
      }
      startReload(){
        if (this.reloading) return;
        this.reloading = true;
        this.reloadTimer = this.reloadDuration;
        audio.reloadMag();
      }
      hurt(amount){
        if (this.damageCooldown>0) return;
        this.hp -= amount;
        this.damageCooldown = 0.6;
        state.shake = Math.min(12, state.shake + 4);
        audio.hurt();
        if (this.hp <= 0){
          gameOver();
        }
      }
      draw(){
        // Player body
        ctx.save();
        // subtle recoil offset
        const rx = -Math.cos(this.aim)*this.recoil*2;
        const ry = -Math.sin(this.aim)*this.recoil*2;
        ctx.translate(rx, ry);

        // glow
        ctx.fillStyle = '#14161c';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r+6, 0, TAU);
        ctx.fill();

        // body
        ctx.fillStyle = '#3aa3ff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, TAU);
        ctx.fill();

        // barrel line
        ctx.strokeStyle = '#cde6ff';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + Math.cos(this.aim)*(this.r+14),
                   this.y + Math.sin(this.aim)*(this.r+14));
        ctx.stroke();

        // eye
        ctx.fillStyle = '#0b1020';
        ctx.beginPath();
        ctx.arc(this.x + Math.cos(this.aim)*8,
                this.y + Math.sin(this.aim)*8, 3, 0, TAU);
        ctx.fill();

        ctx.restore();
      }
    }

    class Splat{
      constructor(x,y){
        this.x=x; this.y=y;
        this.ttl = 60.5; // seconds
        this.blobs = [];
        const n = randInt(8,14);
        for (let i=0;i<n;i++){
          const a = rand(0, TAU);
          const d = rand(2, 22);
          const r = rand(2, 8);
          this.blobs.push({x: this.x + Math.cos(a)*d, y: this.y + Math.sin(a)*d, r});
        }
      }
      update(dt){ this.ttl -= dt; }
      draw(){
        const t = Math.max(0, Math.min(1, this.ttl/3.5));
        const alpha = 0.65 * t;
        // dark undercoat
        ctx.fillStyle = `rgba(80,0,0,${alpha})`;
        for (const b of this.blobs){
          ctx.beginPath(); ctx.arc(b.x+1, b.y+1, b.r*1.1, 0, TAU); ctx.fill();
        }
        // bright blood
        ctx.fillStyle = `rgba(160,10,10,${alpha})`;
        for (const b of this.blobs){
          ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, TAU); ctx.fill();
        }
      }
    }

    class Bullet{
      constructor(x,y,vx,vy, dmg){
        this.x=x; this.y=y; this.vx=vx; this.vy=vy;
        this.px=x; this.py=y; // previous position for trail
        this.r=3; // collision radius (visual tip is smaller)
        this.dmg=dmg;
      }
      update(dt){
        this.px = this.x; this.py = this.y;
        this.x += this.vx*dt;
        this.y += this.vy*dt;
      }
      draw(){
        // trail line
        const ang = Math.atan2(this.vy, this.vx);
        const len = 14; // constant trail length
        const tx = this.x - Math.cos(ang)*len;
        const ty = this.y - Math.sin(ang)*len;
        ctx.strokeStyle = 'rgba(255,209,102,0.9)';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(tx, ty);
        ctx.lineTo(this.x, this.y);
        ctx.stroke();
        // small bright tip
        ctx.fillStyle = '#ffe6a3';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 1.2, 0, TAU);
        ctx.fill();
      }
    }

    class Zombie{
      constructor(x,y, hp, speed, tier, coverDmgRate, scale){
        this.x=x; this.y=y;
        this.tier = Math.max(0, Math.floor(tier||0));
        this.scale = scale || 1;
        this.r = 18 * this.scale * (1 + 0.08*this.tier);
        this.hp=hp;
        this.speed=speed;
        this.baseSpeed = speed;
        this.coverDmgRate = coverDmgRate || 20;
        this.hurtTimer = 0;
        // slow effect
        this.slowMul = 1; // 1 = no slow; <1 = slowed
        this.slowTimer = 0;
      }
      update(dt){
        // Move towards player
        const dx = state.player.x - this.x;
        const dy = state.player.y - this.y;
        const m = norm(dx,dy);
        // update slow timer
        if (this.slowTimer > 0){ this.slowTimer -= dt; if (this.slowTimer <= 0) { this.slowMul = 1; } }
        const sp = this.baseSpeed * this.slowMul;
        this.x += m.x*sp*dt;
        this.y += m.y*sp*dt;
        if (this.hurtTimer>0) this.hurtTimer -= dt;

        // If touches player
        const rr = (this.r + state.player.r);
        if (dist2(this, state.player) < rr*rr){
          state.player.hurt(12);
          // small knockback
          this.x -= m.x*12;
          this.y -= m.y*12;
        }
      }
      hurt(dmg){
        this.hp -= dmg;
        this.hurtTimer = 0.1;
      }
      applySlow(factor, duration){
        // factor in (0,1], duration in seconds
        this.slowMul = Math.min(this.slowMul, Math.max(0.2, factor));
        this.slowTimer = Math.max(this.slowTimer, duration);
      }
      draw(){
        // palette per tier
        const palette = ['#74d874','#5cc45c','#46a946','#318431'];
        const baseCol = palette[Math.min(this.tier, palette.length-1)];
        const color = this.hurtTimer>0 ? '#a6f7a6' : baseCol;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, TAU);
        ctx.fill();

        // face changes with tier
        // eyes
        ctx.fillStyle = '#0b1020';
        const e = Math.max(2, this.r*0.12);
        ctx.beginPath(); ctx.arc(this.x - this.r*0.25, this.y - this.r*0.15, e, 0, TAU); ctx.fill();
        ctx.beginPath(); ctx.arc(this.x + this.r*0.25, this.y - this.r*0.12, e, 0, TAU); ctx.fill();
        // mouth
        if (this.tier <= 0){
          ctx.fillStyle = '#0a0';
          ctx.fillRect(this.x-5, this.y+2, 10, 3);
        } else if (this.tier === 1){
          ctx.fillStyle = '#083';
          ctx.fillRect(this.x-8, this.y+3, 16, 4);
        } else {
          // big mouth with simple fangs
          ctx.fillStyle = '#062';
          ctx.fillRect(this.x-10, this.y+3, 20, 5);
          ctx.fillStyle = '#fff';
          ctx.beginPath(); ctx.moveTo(this.x-4, this.y+3); ctx.lineTo(this.x-2, this.y+8); ctx.lineTo(this.x, this.y+3); ctx.closePath(); ctx.fill();
          ctx.beginPath(); ctx.moveTo(this.x+4, this.y+3); ctx.lineTo(this.x+2, this.y+8); ctx.lineTo(this.x, this.y+3); ctx.closePath(); ctx.fill();
        }
      }
    }

    function spawnOneZombie(weak){
      // Spawn one zombie just outside one of the edges
      let edge;
      if (weak){
        // First weak wave — strictly from one chosen side; later weak waves biased ~80%
        if (state.zombiesSpawned === 0) edge = state.weakSide;
        else edge = (Math.random() < 0.8) ? state.weakSide : randInt(0,3);
      } else {
        edge = randInt(0,3); // 0 top,1 right,2 bottom,3 left
      }
      const margin = 40;
      let x,y;
      if (edge===0){ x = rand(-margin, state.w+margin); y = -margin; }
      else if (edge===2){ x = rand(-margin, state.w+margin); y = state.h+margin; }
      else if (edge===1){ x = state.w+margin; y = rand(-margin, state.h+margin); }
      else { x = -margin; y = rand(-margin, state.h+margin); }
      if (weak){
        const hp = rand(25, 50);
        const sp = rand(70, 110);
        const scale = rand(0.85, 1.0);
        const z = new Zombie(x,y,hp, sp, 0, 6, scale);
        state.zombies.push(z);
      } else {
        const t = state.time;
        const tier = Math.min(3, Math.floor(t/40));
        const hp = 110 + t*4 + tier*30;
        const sp = clamp(90 + t*0.9 + tier*5, 90, 180);
        const scale = 1.0 + tier*0.05;
        const coverDmg = 18 + tier*10;
        const z = new Zombie(x,y,hp, sp, tier, coverDmg, scale);
        state.zombies.push(z);
      }
      state.zombiesSpawned += 1;
    }

    function spawnWave(){
      if (state.weakPhase){
        const left = Math.max(0, 100 - state.zombiesSpawned);
        const n = Math.min(left, randInt(3,7));
        for (let i=0;i<n;i++) spawnOneZombie(true);
        if (state.zombiesSpawned >= 100) state.weakPhase = false;
      } else {
        spawnOneZombie(false);
      }
    }

    function gameOver(){
      state.running = false;
      overlay.classList.add('show');
      final.textContent = 'Счёт: ' + state.score;
      audio.gameOver();
    }

    function restart(){
      state.score = 0;
      state.time = 0;
      state.spawnTimer = 10; // delay first zombie spawn by 10s
      state.spawnInterval = 1.1;
      state.zombiesSpawned = 0;
      state.weakPhase = true;
      state.weakSide = randInt(0,3); // choose a side for weak horde
      state.bullets.length = 0;
      state.zombies.length = 0;
      state.splats.length = 0;
      state.explosions.length = 0;
      state.barrels.length = 0;
      state.quips.length = 0;
      state.shotsFired = 0;
      state.nextQuipAt = randInt(30,50);
      state.covers.length = 0;
      initCovers();
      state.player = new Player(state.w*0.5, state.h*0.5);
      state.phase = 'fight';
      state.running = true;
      overlay.classList.remove('show');
      uiScore.textContent = 'Score: 0';
      uiHP.textContent = 'HP: 100';
    }

    function initCovers(){
      // Build a partial circular ring around the player with gaps, plus a few extra blocks nearby
      const cx = state.w*0.5, cy = state.h*0.5;
      const R = Math.max(120, Math.min(state.w, state.h)*0.25);
      const segments = 12;
      const thickness = 22;
      const segLen = 90;
      // choose gap indices
      const gapCount = 3;
      const gapIdx = new Set();
      while (gapIdx.size < gapCount){ gapIdx.add(randInt(0, segments-1)); }
      for (let i=0;i<segments;i++){
        if (gapIdx.has(i)) continue; // leave a hole
        const theta = (i/segments)*Math.PI*2;
        const ang = theta + Math.PI*0.5; // tangent orientation
        const rcx = cx + Math.cos(theta)*R;
        const rcy = cy + Math.sin(theta)*R;
        const w = segLen * rand(0.9, 1.1);
        const h = thickness * rand(0.9, 1.1);
        const x = rcx - w*0.5;
        const y = rcy - h*0.5;
        const hp = Math.floor(260 + (w*h)/18);
        const cov = new Cover(x,y,w,h,hp);
        cov.angle = ang;
        state.covers.push(cov);
      }
      // Add a few extra blocks near gaps so player can slide them to close holes
      for (const gi of gapIdx){
        const theta = (gi/segments)*Math.PI*2;
        for (let k=0;k<2;k++){
          const offset = (k===0? -1 : 1) * rand(40, 80);
          const rcx = cx + Math.cos(theta)*(R + offset);
          const rcy = cy + Math.sin(theta)*(R + offset);
          const ang = theta + Math.PI*0.5;
          const w = rand(60, 90);
          const h = rand(18, 26);
          const x = rcx - w*0.5;
          const y = rcy - h*0.5;
          const hp = Math.floor(230 + (w*h)/20);
          const cov = new Cover(x,y,w,h,hp);
          cov.angle = ang;
          state.covers.push(cov);
        }
      }
      // place explosive barrels after covers are placed
      initBarrels();
    }

    function update(dt){
      state.time += dt;
      // Increase difficulty
      state.spawnInterval = clamp(1.1 - state.time*0.0015, 0.32, 1.1);
      // Spawning always while running
      state.spawnTimer -= dt;
      if (state.spawnTimer <= 0 && state.running){
        spawnWave();
        state.spawnTimer = state.spawnInterval;
      }

      // Mark covers as not pushed this frame
      for (const c of state.covers) c.pushed = false;

      state.player.update(dt);
      // Player pushes covers with impulse on OBB contact
      for (let k=0; k<state.covers.length; k++){
        const c = state.covers[k];
        const col = circleOBBCollision(c, state.player.x, state.player.y, state.player.r);
        if (col){
          // positional correction (split between player and cover)
          const sep = col.depth + 1e-3;
          const playerShare = 0.35;
          const coverShare = 1 - playerShare;
          state.player.x += col.nx * (sep * playerShare);
          state.player.y += col.ny * (sep * playerShare);
          c.cx -= col.nx * (sep * coverShare);
          c.cy -= col.ny * (sep * coverShare);
          c.pushed = true;
          // impulse based on player's movement into normal
          const mvx = state.player.moveVx, mvy = state.player.moveVy;
          const mvLen = Math.hypot(mvx, mvy);
          const dirx = mvLen ? mvx/mvLen : 0, diry = mvLen ? mvy/mvLen : 0;
          const into = Math.max(0, dirx*col.nx + diry*col.ny);
          const J = (900 + 900*into) * dt * (mvLen / state.player.speed);
          const rpx = col.cx - c.cx; const rpy = col.cy - c.cy;
          c.vx += col.nx * (J * c.invMass);
          c.vy += col.ny * (J * c.invMass);
          c.clampToBounds();
          // avoid overlaps with other covers via circle bounds, revert if overlapping badly
          for (let m=0; m<state.covers.length; m++){
            if (m===k) continue;
            const o = state.covers[m];
            if (Math.hypot(c.cx - o.cx, c.cy - o.cy) < c.radius() + o.radius() - 6){
              c.cx += col.nx * (sep * coverShare); c.cy += col.ny * (sep * coverShare);
              c.vx *= 0.3; c.vy *= 0.3;
              break;
            }
          }
          // extra resolve pass to ensure player is fully outside the cover
          const col2 = circleOBBCollision(c, state.player.x, state.player.y, state.player.r);
          if (col2){
            const sep2 = col2.depth + 0.5;
            state.player.x += col2.nx * sep2;
            state.player.y += col2.ny * sep2;
          }
        }
      }

      // Update bullets and check barrel hits
      for (let i=state.bullets.length-1; i>=0; i--){
        const b = state.bullets[i];
        b.update(dt);
        // hit barrels
        let exploded = false;
        for (let bi=state.barrels.length-1; bi>=0; bi--){
          const br = state.barrels[bi];
          if (!br.alive) continue;
          const rr = br.r + b.r;
          const dx = b.x - br.x, dy = b.y - br.y;
          if (dx*dx + dy*dy <= rr*rr){
            br.alive = false;
            state.barrels.splice(bi,1);
            triggerExplosion(br.x, br.y);
            state.bullets.splice(i,1);
            exploded = true;
            break;
          }
        }
        if (exploded) continue;
        // Despawn beyond map bounds
        if (b.x < -DESPAWN_MARGIN || b.y < -DESPAWN_MARGIN || b.x > state.w + DESPAWN_MARGIN || b.y > state.h + DESPAWN_MARGIN){
          state.bullets.splice(i,1);
        }
      }

      // Update zombies and collisions
      for (let i=state.zombies.length-1; i>=0; i--){
        const z = state.zombies[i];
        z.update(dt);
        // resolve zombie collisions with OBB covers and damage them
        for (let k=state.covers.length-1; k>=0; k--){
          const c = state.covers[k];
          const col = circleOBBCollision(c, z.x, z.y, z.r);
          if (col){
            // push zombie out along normal
            z.x += col.nx * col.depth; z.y += col.ny * col.depth;
            // damage cover gradually
            c.hp -= (z.coverDmgRate||20)*dt;
            if (c.hp <= 0){ state.covers.splice(k,1); continue; }
          }
        }
        // bullets collide
        for (let j=state.bullets.length-1; j>=0; j--){
          const b = state.bullets[j];
          const rr = (z.r + b.r);
          if (dist2(z, b) < rr*rr){
            z.hurt(b.dmg);
            // apply brief slow on hit (affects all tiers)
            if (typeof z.applySlow === 'function') z.applySlow(0.6, 0.6);
            audio.hit();
            state.bullets.splice(j,1);
          }
        }
        if (z.hp <= 0){
          state.zombies.splice(i,1);
          state.score += 1;
          // splat effect
          state.splats.push(new Splat(z.x, z.y));
          audio.splat();
        }
      }

      // Update explosions
      for (let i=state.explosions.length-1; i>=0; i--){
        const e = state.explosions[i];
        e.update(dt);
        if (e.ttl <= 0) state.explosions.splice(i,1);
      }

      // Update scorches
      for (let i=state.scorches.length-1; i>=0; i--){
        const s = state.scorches[i];
        s.update(dt);
        if (s.ttl <= 0) state.scorches.splice(i,1);
      }

      // Update splats (fade and cleanup)
      for (let i=state.splats.length-1; i>=0; i--){
        const s = state.splats[i];
        s.update(dt);
        if (s.ttl <= 0) state.splats.splice(i,1);
      }

      // Update quips
      for (let i=state.quips.length-1; i>=0; i--){
        const q = state.quips[i];
        q.age = (q.age||0) + dt;
        q.ttl -= dt;
        if (q.ttl <= 0) state.quips.splice(i,1);
      }

      // Update barrels
      for (let i=state.barrels.length-1; i>=0; i--){
        const br = state.barrels[i];
        br.update(dt);
        if (!br.alive) state.barrels.splice(i,1);
      }
      // Update covers AFTER handling all collisions/pushes; stop if not pushed
      for (const c of state.covers){
        if (!c.pushed){ c.vx = 0; c.vy = 0; c.av = 0; }
        c.integrate(dt);
      }
      // UI updates
      uiScore.textContent = 'Score: ' + state.score;
      uiHP.textContent = 'HP: ' + clamp(Math.ceil(state.player.hp),0,999);
      uiAmmo.textContent = 'Ammo: ' + (state.player ? (state.player.ammo + ' / ' + state.player.magSize) : '') + (state.player && state.player.reloading ? ' (reload...)' : '');
      if (state.spawnTimer > 0){
        uiCountdown.textContent = 'До атаки: ' + Math.max(0, state.spawnTimer).toFixed(1) + 's';
      } else {
        uiCountdown.textContent = '';
      }

      // screen shake
      state.shake = Math.max(0, state.shake - 40*dt);
    }

    function render(){
      // background
      const shakeX = state.shake ? rand(-state.shake, state.shake) : 0;
      const shakeY = state.shake ? rand(-state.shake, state.shake) : 0;
      ctx.save();
      ctx.translate(shakeX, shakeY);
      ctx.fillRect(-100,-100, state.w+200, state.h+200);

      // subtle grid
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.lineWidth = 1;
      const grid = 40;
      for (let x= (state.time*20)%grid; x<state.w; x+=grid){
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,state.h); ctx.stroke();
      }
      for (let y= (state.time*12)%grid; y<state.h; y+=grid){
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(state.w,y); ctx.stroke();
      }

      // Entities
      for (const s of state.splats) s.draw();
      for (const sc of state.scorches) sc.draw();
      // covers
      for (const c of state.covers) c.draw();
      // barrels
      for (const br of state.barrels) br.draw();
      for (const b of state.bullets) b.draw();
      for (const z of state.zombies) z.draw();
      // explosions overlay
      for (const e of state.explosions) e.draw();
      state.player.draw();

      // quips above player
      if (state.quips.length){
        const baseY = state.player.y - state.player.r - 26;
        ctx.font = '16px monospace';
        ctx.textAlign = 'center';
        for (let i=0;i<state.quips.length;i++){
          const q = state.quips[i];
          const y = baseY - i*18 - (q.age||0)*8;
          const alpha = Math.min(1, Math.max(0, q.ttl/2));
          ctx.strokeStyle = `rgba(0,0,0,${0.7*alpha})`;
          ctx.lineWidth = 3; ctx.lineJoin='round';
          ctx.strokeText(q.text, state.player.x, y);
          ctx.fillStyle = `rgba(255,255,255,${alpha})`;
          ctx.fillText(q.text, state.player.x, y);
        }
      }

      ctx.restore();

      // crosshair
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(state.mouse.x, state.mouse.y, 10, 0, TAU);
      ctx.moveTo(state.mouse.x-14, state.mouse.y);
      ctx.lineTo(state.mouse.x-4, state.mouse.y);
      ctx.moveTo(state.mouse.x+14, state.mouse.y);
      ctx.lineTo(state.mouse.x+4, state.mouse.y);
      ctx.moveTo(state.mouse.x, state.mouse.y-14);
      ctx.lineTo(state.mouse.x, state.mouse.y-4);
      ctx.moveTo(state.mouse.x, state.mouse.y+14);
      ctx.lineTo(state.mouse.x, state.mouse.y+4);
      ctx.stroke();
    }

    // Main loop
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now - last)/1000);
      last = now;
      if (state.player) {
        if (state.running) update(dt);
        render();
      }
      requestAnimationFrame(loop);
    }

    // Start
    restart();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
